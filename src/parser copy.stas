






;; (toplevel_constants[idx] token_stream[idx])
;fn replace_as_constant 2 0 {
;	auto const_idx 1
;	swap pop const_idx
;	
;	dup token_stream[]
;	    const_idx toplevel_constants[] rConstant.tok token_stream[]
;	    swap
;	    sizeof(Token)
;	    memcpy
;
;	dup token_stream[] Token.tok  Tok.number_lit                                 w32
;	    token_stream[] Token.data const_idx toplevel_constants[] rConstant.value w64
;}









fn parse.const_expression {
	auto rs_c 1 pos pop rs_c

	pos 2 + pop pos
	pos token_stream.len >= if {
		rs_c 'unexpected EOF when parsing constant expression' error.Tok
	}

	auto sv 1
	rs_c 1 + token_stream[] rToken.tok Tok.name != if {
		rs_c 1 + 'constant expression name must not be in instrinsic' error.Tok
	}
	rs_c 1 + token_stream[] rToken.data pop sv

	sv is_function_name UINT64_MAX != if {
		rs_c 1 + 'duplicate constant expression name as existing function name' error.Tok
	}
	sv is_toplevel_name_bool if {
		rs_c 1 + 'constant expression name as duplicate top level variable name' error.Tok
	}
	pos token_stream[] rToken.tok Tok.l_cb != if {
		pos 'a scope must follow a const expression decl' error.Tok
	}

	0 assert -> 'unimplemented'

;	; (name inst_start tok value)
;		sv
;		ir_stream.len
;		pos 1 -
;		UINT64_MAX
;	toplevel_constants<<
;
;	true pop is_still_evaluating_constant
;	sp.len 0 = assert
}

; ( -- VarTyp string_view size )
fn parse.any_variable 0 3 {
	0 assert -> 'unimplemented'
	
	
	auto rs_c 1
	pos pop rs_c

	pos 2 + pop pos
	pos token_stream.len >= if {
		rs_c 'unexpected EOF when parsing variable decl' error.Tok
	}

	rs_c token_stream[] rToken.tok
	Tok.reserve = if {
		VarTyp.buffer
	} else {
		VarTyp.stack
	}

	; (VarTyp)
	auto sv 1

	rs_c 1 + token_stream[] dup
	rToken.tok Tok.name != if {
		rs_c 1 + 'variable name must not be an intrinsic' error.Tok
	}
	rToken.data pop sv
	sv is_function_name UINT64_MAX != if {
		rs_c 1 + 'variable decl must not be a function' error.Tok
	}

	pos token_stream[] rToken.tok
	Tok.name = if {
		0 assert -> 'unimplemented'
;		auto c_name 1
;		pos token_stream[] rToken.data is_constant_name pop c_name
;
;		c_name UINT64_MAX != if {
;			c_name pos replace_as_constant
;		}
	}
	pos token_stream[] rToken.tok
	Tok.number_lit != if {
		pos 'variable decl must specify size in bytes' error.Tok
	}

	sv
	
	rs_c token_stream[] rToken.tok
	Tok.reserve = if {
		pos token_stream[] rToken.data
	} else {
		pos token_stream[] rToken.data
		dup 0 = if {
			pos 'auto variables cannot have a size of zero' error.Tok
		}
		8 *
	}
	; (VarTyp string_view size)
}

fn parse.fn_complex_body_tokens {
	pos token_stream[] rToken.tok

	; fn ir   (inst data)
	; fn ir_p (pos inst data)

	dup dup dup Tok.reserve = rot Tok.auto = rot Tok.const = | | if {
		function_context rFunction.attributes
		FnAttribute.inline FnAttribute.is_set if {
			pos 'functions marked as inline cannot contain variable declarations' error.Tok
		}

		auto search_p 1
		0 pop search_p

	;	scope_context.len 0 != if {
	;		scope_context.top rScope.var_scope
	;		pop search_p
	;		
	;		scope_context.len 1 -
	;		while 1 {
	;			dup scope_context[] rScope.typ
	;			ScopeTyp.while_block = if {
	;				pos 'cannot define variables inside of while headers' error.Tok
	;			}
	;	
	;			dup 0 = if {
	;				break
	;			}
	;			--
	;		}
	;		drop
	;	}
		; TODO: Maybe above should be removed? I don't see a problem with it.
		;       Make sure to keep `search_p` though.
		
		parse.any_variable
		; (VarTyp string_view size)
		auto var_string 2
		over string_view_to_str pop var_string

		var_context.len search_p != if {
			var_context.len 1 -
			while 1 {
				dup var_context[] rVariable.name
				string_view_to_str var_string
				streq if {
					pos 1 - 'duplicate variable name' error.Tok
				}

				dup search_p = if {
					break
				}
				--
			}
			drop
		}

		auto size 1
		dup pop size

		; (VarTyp string_view size)

		; (typ size a_sp idx name)
					                        swap
			function_context rFunction.a_sp swap
			pos 2 -                         swap
		var_context<<

		function_context Function.a_sp
			function_context rFunction.a_sp size +
		w32
		function_context Function.forbid_inline 1 w8
	} elif dup dup Tok.pop = swap Tok.addr = | {
		auto is_pop 1

		pos token_stream[] rToken.tok Tok.pop = pop is_pop

		pos ++ pop pos
		pos token_stream.len >= if {
			pos 1 - 'unexpected EOF' error.Tok
		}
		pos token_stream[] rToken.tok Tok.name != if {
			pos 'expected name of variable' error.Tok
		}

		auto sv    1 pos token_stream[] rToken.data pop sv
		auto f_idx 1 UINT64_MAX                     pop f_idx
		auto found 1 false                          pop found

		sv search_variable_name pop f_idx
		f_idx UINT64_MAX != if {
			auto var 1
			f_idx var_context[] pop var

			-> 0 {
				var rVariable.typ VarTyp.buffer = if {
					is_pop if {
						pos 'cannot pop into a buffer' error.Tok
					} else {
						pos 'cannot get address of a buffer, buffer is already an address' error.Tok
					}
				} elif var rVariable.typ VarTyp.stack = {
					is_pop if {					
						auto to_pop 1
						var rVariable.size 8 / pop to_pop

						sp.len to_pop < if {
							pos 'not enought values on the stack to pop into an automatic variable' error_st.Tok
						}

						sp.len to_pop - pop sp.len

						Inst.pop_local_stack_var
							to_pop 32 <<
							var rVariable.a_sp |
						ir
					} else {
						1 pos -- sp_push_p

						Inst.push_local_addr
							var rVariable.a_sp
						ir
					}
				} else {
					0 assert
				}
			}
			true pop found
		}
		found ! if {
			sv is_global_var_name pop f_idx
			f_idx UINT64_MAX != if {
				auto var 1
				f_idx global_var_context[] pop var

				-> 0 {
					var rVariable.typ VarTyp.buffer = if {
						is_pop if {
							pos 'cannot pop into a buffer' error.Tok
						} else {
							pos 'cannot get address of a buffer, buffer is already an address' error.Tok
						}
					} elif var rVariable.typ VarTyp.stack = {
						is_pop if {
							auto to_pop 1
							var rVariable.size 8 / pop to_pop

							sp.len to_pop < if {
								pos 'not enought values on the stack to pop into an automatic variable' error_st.Tok
							}
							sp.len to_pop - pop sp.len

							Inst.pop_global_stack_var f_idx ir
						} else {
							1 pos -- sp_push_p
							Inst.push_global_var_name f_idx ir
						}
					} else {
						0 assert
					}
				}
				true pop found
			}
		}
		found ! if {
			pos 'unknown variable' error.Tok
		}
	} elif dup Tok.name = {
		auto sv    1 pos token_stream[] rToken.data pop sv
		auto f_idx 1 UINT64_MAX                     pop f_idx
		auto found 1 false                          pop found

		; functions cannot be shadowed but variables can

		sv is_function_name pop f_idx
		f_idx UINT64_MAX != if {
			Inst.fn_call f_idx ir

			function_context_idx f_idx = if {
				function_context Function.forbid_inline 1 w8
				function_context rFunction.attributes FnAttribute.inline FnAttribute.is_set if {
					pos 'inline functions cannot call themselves' error.Tok
				}
				function_context Function.tail_r_label label_allocate w32
			}

			f_idx functions[] rFunction.attributes
			FnAttribute.noreturn FnAttribute.is_set if {
				parse.push_early_ret_with_pos
			}

			sp.len
			f_idx functions[] rFunction.argc
			< if {
				pos 'not enough values to consume for function call' error_st.Tok
			}

			f_idx functions[] rFunction.argc
			f_idx functions[] rFunction.retc
			sp_assert

			true pop found
		}
		found ! if {
			sv search_variable_name pop f_idx
			f_idx UINT64_MAX != if {
				auto var 1
				f_idx var_context[] pop var

				-> 0 {
					var rVariable.typ VarTyp.buffer = if {
						Inst.push_local_addr var rVariable.a_sp ir
						1 sp_push
					} elif var rVariable.typ VarTyp.stack = {
						auto to_push 1
						var rVariable.size 8 / pop to_push

						Inst.push_local_stack_var
							to_push 32 <<
							var rVariable.a_sp |
						ir

						to_push sp_push
					} else {
						0 assert
					}
				}
				true pop found
			}
		}
		found ! if {
			sv is_global_var_name pop f_idx
			f_idx UINT64_MAX != if {
				auto var 1
				f_idx global_var_context[] pop var

				-> 0 {
					var rVariable.typ VarTyp.buffer = if {
						Inst.push_global_var_name f_idx ir
						1 sp_push
					} elif var rVariable.typ VarTyp.stack = {
						Inst.push_global_stack_var f_idx ir
						var rVariable.size 8 / sp_push
					} else {
						0 assert
					}
				}
				true pop found
			}
		}
	;	found ! if {
	;		sv is_constant_name pop f_idx
	;		f_idx UINT64_MAX != if {
	;			auto c_name 1
	;			sv is_constant_name pop c_name
	;
	;			c_name UINT64_MAX != if {
	;				c_name pos replace_as_constant
	;				pos -- pop pos
	;				true pop found
	;			}
	;		}
	;	}
		found ! if {
			pos 'unknown function call or variable' error.Tok
		}
	} elif dup Tok.if_block = {
		sp.len 0 = if {
			pos 'no value on stack to consume for if statement' error.Tok
		}
		sp.len -- pop sp.len

		auto lbl 1
		label_allocate pop lbl

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.if_block
			sp.len
			0
			pos
			lbl
			label_allocate
			var_context.len
		scope_context<<

		Inst.do_cond_jmp lbl ir
		
		pos ++ pop pos
		pos token_stream.len >= if {
			pos 1 - 'unexpected EOF when parsing if statement' error.Tok
		}
		pos token_stream[] rToken.tok Tok.l_cb != if {
			pos 'a scope must come after an if statement' error.Tok
		}
	} elif dup Tok.while_block = {
		auto lbl 1
		label_allocate pop lbl

		Inst.label lbl ir

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.while_block
			sp.len
			0
			pos
			lbl
			0
			var_context.len
		scope_context<<
	} elif dup Tok.break_block = {
		scope_context.len 0 = if {
			pos 'not inside while loop body' error.Tok
		}

		auto f 1
		false pop f

		scope_context.len 1 -
		while 1 {
			auto scope 1
			dup scope_context[] pop scope

			scope rScope.typ ScopeTyp.while_block_scope = if {
				Inst.do_jmp scope rScope.label_id ir
				
				true pop f
				break
			}

			dup 0 = if {
				break
			}
			--
		}
		drop

		f ! if {
			pos 'not inside while loop body' error.Tok
		}

		parse.push_early_ret_with_pos
	} elif dup Tok.continue_block = {
		scope_context.len 0 = if {
			pos 'not inside while loop body' error.Tok
		}

		auto f 1
		false pop f

		scope_context.len 1 -
		while 1 {
			dup scope_context[] rScope.typ
			ScopeTyp.while_block_scope = if {
				dup --
				scope_context[] dup rScope.typ ScopeTyp.while_block = assert
				
				Inst.do_jmp swap rScope.label_id ir
				true pop f
				break
			}

			dup 0 = if {
				break
			}
			--
		}
		drop

		f ! if {
			
		}

		parse.push_early_ret_with_pos
	} elif dup Tok.l_cb = {
		while
			scope_context.len 0 > if {
				scope_context.top rScope.typ ScopeTyp.early_ret = if {
					scope_context.top rScope.idx

					dup 0 != if {
						dup pos -- != if {
							++ 'unreachable code' error.Tok 
						} else {
							drop
						}
					} else {
						drop
					}
					
					true
				} else {
					false
				}
			} else {
				false
			}
		{
			scope_context.len -- pop scope_context.len
		}

		scope_context.len 0 != if {
			
		} else {
			parse.push_empty_scope
		}
	} elif dup Tok.r_cb = {
		
		
		scope_context.len 0 > if {
			

			


	} elif dup Tok.ret = {
		
	} elif dup Tok.arrw = {
		auto arrw_c 1
		pos pop arrw_c

		pos 2 + pop pos
		pos token_stream.len >= if {
			arrw_c 'unexpected EOF when parsing checked scope' error.Tok
		}

		arrw_c 1 + token_stream[]
		dup rToken.tok Tok.number_lit != if {
			arrw_c 1 + 'a number must appear after the arrow assert operator' error.Tok
		}

		auto num 1
		rToken.data pop num

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.checked_scope
			num sp.len +
			0
			arrw_c
			0
			0
			var_context.len
		scope_context<<

		pos token_stream[]
		rToken.tok Tok.l_cb != if {
			pos 'a scope must come after the arrow assert operator' error.Tok
		}
	} elif dup Tok.string_lit = {
		Inst.push_str pos token_stream[] rToken.data ir
		2 sp_push
	} elif dup Tok.w8 = {
		Inst.w8 0 ir
		2 0 sp_assert
	} elif dup Tok.w16 = {
		Inst.w16 0 ir
		2 0 sp_assert
	} elif dup Tok.w32 = {
		Inst.w32 0 ir
		2 0 sp_assert
	} elif dup Tok.w64 = {
		Inst.w64 0 ir
		2 0 sp_assert
	} elif dup Tok.r8 = {
		Inst.r8 0 ir
		1 1 sp_assert
	} elif dup Tok.r16 = {
		Inst.r16 0 ir
		1 1 sp_assert
	} elif dup Tok.r32 = {
		Inst.r32 0 ir
		1 1 sp_assert
	} elif dup Tok.r64 = {
		Inst.r64 0 ir
		1 1 sp_assert
	} elif dup Tok.trap_breakpoint = {
		Inst.trap_breakpoint 0 ir
		1 1 sp_assert
	} elif dup Tok.syscall0 = {
		Inst.syscall0 0 ir
		1 1 sp_assert
	} elif dup Tok.syscall1 = {
		Inst.syscall1 0 ir
		2 1 sp_assert
	} elif dup Tok.syscall2 = {
		Inst.syscall2 0 ir
		3 1 sp_assert
	} elif dup Tok.syscall3 = {
		Inst.syscall3 0 ir
		4 1 sp_assert
	} elif dup Tok.syscall4 = {
		Inst.syscall4 0 ir
		5 1 sp_assert
	} elif dup Tok.syscall5 = {
		Inst.syscall5 0 ir
		6 1 sp_assert
	} elif dup Tok.syscall6 = {
		Inst.syscall6 0 ir
		7 1 sp_assert
	} elif dup Tok.argc = {
		Inst.push_argc 0 ir
		1 sp_push
	} elif dup Tok.argv = {
		Inst.push_argv 0 ir
		1 sp_push
	} elif dup Tok.envp = {
		Inst.push_envp 0 ir
		1 sp_push
	} else {
		pos 'unknown function local token' error.Tok
	}
	
	drop
}

fn parse.assert {
	sp.len 0 = if {
		pos 'no value on stack to consume for assertion' error.Tok
	}
	sp.len -- pop sp.len

	; Inst._assert

	auto contains_message 1
	false pop contains_message

	pos 2 + token_stream.len < if {
		pos 1 + token_stream[] rToken.tok Tok.arrw       = 
		pos 2 + token_stream[] rToken.tok Tok.string_lit =
		& if {
			true pop contains_message
		}
	}

	auto sv 1			
	pos '' error.Tok.to_string_view pop sv

	contains_message if {	
		sv "assertation failed, '" push_string_view
		sv
			pos 2 + token_stream[] rToken.data string_view_to_str
		push_string_view
		sv "'\n" push_string_view
		sv push_nul

		Inst._assert sv ir
		pos 2 + pop pos
	} else {
		sv 'assertation failed\n' push_string_view
		sv push_nul
		
		Inst._assert sv ir
	}
}

fn parse.fn_body_tokens {
	pos token_stream[] rToken.tok

	; fn ir   (inst data)
	; fn ir_p (pos inst data)

	dup Tok._assert = if {
		parse.assert
	} elif dup Tok.number_lit = {
		Inst.push_num pos token_stream[] rToken.data ir
		1 sp_push
	} elif dup Tok.plus = {
		Inst.plus 0 ir
		2 1 sp_assert
	} elif dup Tok.sub = {
		Inst.sub 0 ir
		2 1 sp_assert
	} elif dup Tok.mul = {
		Inst.mul 0 ir
		2 1 sp_assert
	} elif dup Tok.div = {
		Inst.div 0 ir
		2 1 sp_assert
	} elif dup Tok.mod = {
		Inst.mod 0 ir
		2 1 sp_assert
	} elif dup Tok.inc = {
		Inst.inc 0 ir
		1 1 sp_assert
	} elif dup Tok.dec = {
		Inst.dec 0 ir
		1 1 sp_assert
	} elif dup Tok.divmod = {
		Inst.divmod 0 ir
		2 2 sp_assert
	} elif dup Tok.shr = {
		Inst.shr 0 ir
		2 1 sp_assert
	} elif dup Tok.shl = {
		Inst.shl 0 ir
		2 1 sp_assert
	} elif dup Tok.b_and = {
		Inst.b_and 0 ir
		2 1 sp_assert
	} elif dup Tok.b_or = {
		Inst.b_or 0 ir
		2 1 sp_assert
	} elif dup Tok.b_not = {
		Inst.b_not 0 ir
		1 1 sp_assert
	} elif dup Tok.not = {
		Inst.not 0 ir
		1 1 sp_assert
	} elif dup Tok.b_xor = {
		Inst.b_xor 0 ir
		2 1 sp_assert
	} elif dup Tok.swap = {
		Inst.swap 0 ir
		2 sp_has
			sp.pop
			sp.pop
			swap
			sp<<
			sp<<
	} elif dup Tok.dup = {
		Inst.dup 0 ir
		1 sp_has
		sp.top sp<<
	} elif dup Tok.over = {
		Inst.over 0 ir
		2 sp_has
		sp.len 2 - sp[] sp<<
	} elif dup Tok.over2 = {
		Inst.over2 0 ir
		3 sp_has
		sp.len 3 - sp[] sp<<
	} elif dup Tok.rot = {
		Inst.rot 0 ir
		3 sp_has
			sp.pop
			sp.pop
			sp.pop
			rot rot
			sp<<
			sp<<
			sp<<
	} elif dup Tok.rot4 = {
		Inst.rot4 0 ir
		4 sp_has
			sp.pop
			sp.pop
			sp.pop
			sp.pop
			rot4 rot4 rot4
			sp<<
			sp<<
			sp<<
			sp<<
	} elif dup Tok.drop = {
		Inst.drop 0 ir
		1 0 sp_assert
	} elif dup Tok.equ = {
		Inst.equ 0 ir
		2 1 sp_assert
	} elif dup Tok.nequ = {
		Inst.nequ 0 ir
		2 1 sp_assert
	} elif dup Tok.gt = {
		Inst.gt 0 ir
		2 1 sp_assert
	} elif dup Tok.lt = {
		Inst.lt 0 ir
		2 1 sp_assert
	} elif dup Tok.gte = {
		Inst.gte 0 ir
		2 1 sp_assert
	} elif dup Tok.lte = {
		Inst.lte 0 ir
		2 1 sp_assert
	} elif dup Tok.s_gt = {
		Inst.s_gt 0 ir
		2 1 sp_assert
	} elif dup Tok.s_lt = {
		Inst.s_lt 0 ir
		2 1 sp_assert
	} elif dup Tok.s_gte = {
		Inst.s_gte 0 ir
		2 1 sp_assert
	} elif dup Tok.s_lte = {
		Inst.s_lte 0 ir
		2 1 sp_assert
	} else {
		function_context NULL != if {
			parse.fn_complex_body_tokens
		} else {
			pos token_stream[] rToken.tok Tok.const = if {
				pos 'cannot define constant expression inside a constant expression' error.Tok
			}
			pos 'unknown constant expression token' error.Tok
		}
	}
	drop
}

fn stas.parse {
	UINT64_MAX pop main_fn_idx
	0 pop pos

	while pos token_stream.len < {
		is_still_evaluating_constant true != 
		function_context NULL =
		& if {
			pos token_stream[] rToken.tok

			dup Tok.fn_decl = if {
				parse.fn_decl
			} elif dup dup dup Tok.reserve = rot Tok.auto = rot Tok.const = | | {
				parse.any_variable
				over is_toplevel_name_bool if {
					pos 1 - 'duplicate top level variable name' error.Tok
				}
				; (VarTyp string_view size)

				; (typ size a_sp idx name)
					        swap
					0       swap
					pos 2 - swap
				global_var_context<<
			} elif dup Tok.sub = {
				pos ++ pop pos

				pos token_stream.len >= if {
					pos -- "unexpected EOF when parsing function attribute" error.Tok
				}

				pos token_stream[]
				dup rToken.tok Tok.name != if {
					pos "function attribute must be a name" error.Tok
				}
				rToken.data string_view_to_str FnAttribute.from_str? ! if {
					pos "unknown function attribute" error.Tok
				}
				function_attributes | pop function_attributes
			} else {
				pos "unknown toplevel token" error.Tok
			}
			drop
		} else {
			function_context NULL = if {
				pos token_stream[] rToken.tok

				dup Tok.r_cb = if {
					0 assert -> 'unimplemented'

;					0 pop const_stack.len
;
;					toplevel_constants.top rConstant.inst_start
;					while dup ir_stream.len < {
;						dup eval_one_inst assert -> 'unreachable'
;						++
;					}
;					drop
;
;					const_stack.len 0 = if {
;						toplevel_constants.top rConstant.tok
;						'constant expression must contain a value'
;						error.Tok
;					}
;
;					const_stack.len 1 > if {
;						toplevel_constants.top rConstant.tok
;						'more than one unhandled value on left on the constant expression'
;						error_st.Tok
;					}
;
;					0                                           pop sp.len
;					toplevel_constants.top rConstant.inst_start pop ir_stream.len
;
;					toplevel_constants.top Constant.value
;						const_stack.pop
;					w64
;
;					false pop is_still_evaluating_constant
;					const_stack.len 0 = assert
				} elif dup Tok.name = {
					0 assert -> 'unimplemented'

;					auto c_name 1
;					pos token_stream[] rToken.data is_constant_name pop c_name
;
;					c_name UINT64_MAX != if {
;						c_name pos replace_as_constant
;						pos -- pop pos
;					} else {
;						pos 'unknown constant variable' error.Tok
;					}
				} else {
					parse.fn_body_tokens
				}
				drop
			} else {
				parse.fn_body_tokens
			}
		}

		pos ++ pop pos
	}

	var_context.len 0 = assert 
	sp.len          0 = assert

	scope_context.len 0 != if {
		token_stream.len -- "unclosed scopes on parser finish" error.Tok
	}
	function_context NULL != if {
		token_stream.len -- "unexpected EOF when parsing function, scopes may be unclosed" error.Tok	
	}
}