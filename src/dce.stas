const dce.inline_cutoff { 12 }

const   slits.cap     { 1024                    }
const   sizeof(slits) { sizeof(u64) slits.cap * }
auto    slits.len     1
reserve slits         sizeof(slits)

; (u64)
fn slits<< 1 0 {
	slits.len slits.cap < assert
	slits slits.len sizeof(u64) * + swap w32
	slits.len ++ pop slits.len
}

auto used_functions    1
auto inlined_functions 1

; (idx -- u64)
fn slits[] 1 1 {
	dup slits.cap < assert
	sizeof(u64) * slits + r64
}

auto dce.max_stack_frame 1

const dce.baseline_rstack_size { 64 1024 * }

; (stack_frame functions[idx])
fn dce.recurse_function 2 0 {
	auto fn_c  1
	functions[] pop fn_c

	auto st_frame 1 pop st_frame

	fn_c Function.is_used true w8
	used_functions ++ pop used_functions

	fn_c rFunction.end_inst 1 + fn_c rFunction.start_inst -
	dce.inline_cutoff >= if {
		fn_c Function.forbid_inline true w8
		inlined_functions ++ pop inlined_functions
	}
	fn_c rFunction.forbid_inline if {
		st_frame
			sizeof(u64) +
			fn_c rFunction.a_sp +
		pop st_frame
	}

	auto ir_data 1
	auto pos     1

	fn_c rFunction.start_inst pop pos

	while pos fn_c rFunction.end_inst < {
		pos ir_stream[] rIR.data pop ir_data
		pos ir_stream[] rIR.inst
		
		dup Inst.fn_call = if {
			ir_data functions[] fn_c = if {
				auto jmp_pos 1
				auto in_pos  1
				
				UINT64_MAX pop jmp_pos
				pos        pop in_pos

				while true {
					in_pos ++ pop in_pos
					
					in_pos ir_stream[] rIR.data pop ir_data
					in_pos ir_stream[] rIR.inst

					dup Inst.label = if {
						ir_data jmp_pos = if {
							UINT64_MAX pop jmp_pos
						}
					} elif dup Inst.do_jmp = {
						jmp_pos UINT64_MAX = if {
							ir_data pop jmp_pos
						}
					} elif dup Inst.fn_leave = {
						pos ir_stream[]
						dup IR.inst Inst.do_jmp w32
							IR.data fn_c rFunction.tail_r_label w64
					
						break
					} else {
						jmp_pos UINT64_MAX = if {
							break
						}
					}
				}
				drop
			}
			pos ir_stream[] rIR.inst Inst.fn_call = if {
				pos ir_stream[] rIR.data functions[]
				dup fn_c = if {
					; cannot relibly determine stack usage
					UINT64_MAX pop dce.max_stack_frame
				}
				rFunction.is_used ! if {
					st_frame ir_data dce.recurse_function
				}
			}
		} elif dup dup Inst.push_str = swap Inst._assert = | {
			slits.len
			ir_data slits<<
			pos ir_stream[] IR.data swap w64
		}
		drop

		pos ++ pop pos
	}
	
	pos ir_stream[] rIR.inst Inst.fn_leave = assert

	st_frame dce.max_stack_frame > if {
		st_frame pop dce.max_stack_frame
	}
}

fn stas.dce 0 0 {
	main_fn_idx UINT64_MAX = if {
		"no main function" error.generic_fatal
	}

	main_fn_idx functions[] Function.forbid_inline true w8
	
	0 pop used_functions
	0 pop inlined_functions
	0 pop dce.max_stack_frame

	0 main_fn_idx dce.recurse_function

	dce.max_stack_frame UINT64_MAX = if {
		; "cannot reliably determine stack size\n" eputs
		dce.baseline_rstack_size pop dce.max_stack_frame
	}
}