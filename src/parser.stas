auto label_c 1

fn label_allocate 0 1 {
	label_c dup ++ pop label_c
}

auto main_fn_idx          1
auto function_context     1
auto function_context_idx 1
auto function_attributes  1

; ( str len -- idx )
fn is_function_name 2 1 {
	functions.len 0 = if {
		drop drop
		-1
		ret
	}

	auto lit 2 pop lit

	0
	while dup functions.len < {
		dup functions[] rFunction.name string_view_to_str
		lit streq if {
			ret
		}
		++
	}
	drop
	-1
}

; ( str len search_idx -- idx )
fn search_variable_name 3 1 {
	auto search_p 1 pop search_p

	var_context.len search_p <= if {
		drop drop
		-1
		ret
	}

	auto lit 2 pop lit

	var_context.len 1 -
	while 1 {
		dup var_context[] rVariable.name string_view_to_str
		lit streq if {
			ret
		}

		dup search_p = if {
			break
		}
		--
	}
	drop
	-1
}


; ( str len -- idx )
fn search_variable_name_global 2 1 {
	auto lit 2 pop lit

	scope_context.len 0 > if {
		0 scope_context[] rScope.var_scope ; fn scope top
	} else {
		var_context.len
	}
	0
	; (cap idx)
	while dup over2 < {
		dup var_context[] rVariable.name string_view_to_str
		lit streq if {
			swap drop
			ret
		}
		++
	}
	drop drop
	-1
}

fn parse.push_empty_scope {
	; (typ sp sp2 idx label_id label_id2 var_scope)
		ScopeTyp.scope
		sp.len
		0
		pos
		0
		0
		var_context.len
	scope_context<<
}

fn parse.push_early_ret {
	scope_context.len sizeof(Scope) * scope_context +
	dup Scope.typ ScopeTyp.early_ret w32
	    Scope.idx 0                  w32

	scope_context.len ++ pop scope_context.len
	scope_context.len scope_context.cap < assert
}

fn parse.push_early_ret_with_pos {
	scope_context.len sizeof(Scope) * scope_context +
	dup Scope.typ ScopeTyp.early_ret w32
	    Scope.idx pos                w32

	scope_context.len ++ pop scope_context.len
	scope_context.len scope_context.cap < assert
}

; ( Tok -- bool )
fn parse.lookahead? 1 1 {
	pos ++
	dup token_stream.len >= if {
		drop drop false ret
	}
	token_stream[] rToken.tok =
}

; ( Tok -- bool )
fn parse.expect? 1 1 {
	; `pos` will be unchanged on EOF
	pos ++
	dup token_stream.len >= if {
		drop drop false ret
	}
	token_stream[] rToken.tok =
	pos ++ pop pos
}

; ( -- Tok bool )
fn parse.next_eof? 0 2 {
	pos ++ pop pos
	pos token_stream.len >= if {
		-1 false ret
	}
	pos token_stream[] rToken.tok
	true
}

fn parse.fn_decl {
	auto _argc 1
	auto _retc 1
	auto fn_c  1 pos pop fn_c
	
	Tok.name parse.expect? ! if {
		pos 'function name must not be an intrinsic' error.Tok
	}

	auto name 2
		pos token_stream[] rToken.data string_view_to_str
	pop name
	
	name drop r8 `_` = if {
		pos 'a function name cannot begin with an an underscore' error.Tok
	}
	name is_function_name -1 != if {
		pos 'duplicate function name' error.Tok
	}
	name search_variable_name_global -1 != if {
		pos 'function name already exists as variable name' error.Tok
	}
	parse.next_eof? ! if {
		pos 'unexpected EOF in function declaration' error.Tok
	}
	dup Tok.l_cb = if {
		0 pop _argc
		0 pop _retc
	} elif dup Tok.number_lit = {
		Tok.number_lit parse.expect? ! if {
			pos 'function return and argument counts must be numbers' error.Tok
		}

		fn_c 2 + token_stream[] rToken.data pop _argc
		fn_c 3 + token_stream[] rToken.data pop _retc

		Tok.l_cb parse.expect? ! if {
			fn_c 'new scope must proceed after function header' error.Tok
		}
	} else {
		pos 'unknown token in function declaration' error.Tok
	}
	drop

	function_attributes FnAttribute.is_conflict if {
		fn_c 'function attributes conflict' error.Tok
	}

	functions.len sizeof(Function) * functions + pop function_context
	functions.len                                pop function_context_idx
		_argc
		_retc
		fn_c ++ token_stream[] rToken.data
		ir_stream.len
		0 ; end_inst
		0 ; a_sp
		name 'main' streq if {
			function_attributes FnAttribute.inline FnAttribute.is_set if {
				fn_c 'the main function is not inlinable' error.Tok
			}

			_argc 0 !=
			_retc 0 != | if {
				fn_c 'the main function must accept and return zero values' error.Tok
			}

			functions.len pop main_fn_idx
			1 1 ; is_used, forbid_inline
		} else {
			0 ; is_used

			function_attributes FnAttribute.noinline FnAttribute.is_set if {
				1
			} else {
				0
			}
		}
		function_attributes
	functions<<

	fn_c Inst.fn_prelude function_context_idx ir_p
	_argc fn_c sp_push_p

	sp.len 0 = assert
	; 0 pop function_attributes

	; (typ sp sp2 idx label_id label_id2 var_scope)
		ScopeTyp.function
		0
		0
		pos
		0
		0
		var_context.len
	scope_context<<
}

; ( bool )
fn parse.basic_token? 0 1 {
	pos token_stream[] rToken.tok

	; fn ir   (inst data)
	; fn ir_p (pos inst data)

	dup Tok._assert = if {
		0 assert -> 'unimplemented'
	;	parse.assert
	} elif dup Tok.number_lit = {
		Inst.push_num pos token_stream[] rToken.data ir
		1 sp_push
	} elif dup Tok.plus = {
		Inst.plus 0 ir
		2 1 sp_assert
	} elif dup Tok.sub = {
		Inst.sub 0 ir
		2 1 sp_assert
	} elif dup Tok.mul = {
		Inst.mul 0 ir
		2 1 sp_assert
	} elif dup Tok.div = {
		Inst.div 0 ir
		2 1 sp_assert
	} elif dup Tok.mod = {
		Inst.mod 0 ir
		2 1 sp_assert
	} elif dup Tok.inc = {
		Inst.inc 0 ir
		1 1 sp_assert
	} elif dup Tok.dec = {
		Inst.dec 0 ir
		1 1 sp_assert
	} elif dup Tok.divmod = {
		Inst.divmod 0 ir
		2 2 sp_assert
	} elif dup Tok.shr = {
		Inst.shr 0 ir
		2 1 sp_assert
	} elif dup Tok.shl = {
		Inst.shl 0 ir
		2 1 sp_assert
	} elif dup Tok.b_and = {
		Inst.b_and 0 ir
		2 1 sp_assert
	} elif dup Tok.b_or = {
		Inst.b_or 0 ir
		2 1 sp_assert
	} elif dup Tok.b_not = {
		Inst.b_not 0 ir
		1 1 sp_assert
	} elif dup Tok.not = {
		Inst.not 0 ir
		1 1 sp_assert
	} elif dup Tok.b_xor = {
		Inst.b_xor 0 ir
		2 1 sp_assert
	} elif dup Tok.swap = {
		Inst.swap 0 ir
		2 sp_has
			sp.pop
			sp.pop
			swap
			sp<<
			sp<<
	} elif dup Tok.dup = {
		Inst.dup 0 ir
		1 sp_has
		sp.top sp<<
	} elif dup Tok.over = {
		Inst.over 0 ir
		2 sp_has
		sp.len 2 - sp[] sp<<
	} elif dup Tok.over2 = {
		Inst.over2 0 ir
		3 sp_has
		sp.len 3 - sp[] sp<<
	} elif dup Tok.rot = {
		Inst.rot 0 ir
		3 sp_has
			sp.pop
			sp.pop
			sp.pop
			rot rot
			sp<<
			sp<<
			sp<<
	} elif dup Tok.rot4 = {
		Inst.rot4 0 ir
		4 sp_has
			sp.pop
			sp.pop
			sp.pop
			sp.pop
			rot4 rot4 rot4
			sp<<
			sp<<
			sp<<
			sp<<
	} elif dup Tok.drop = {
		Inst.drop 0 ir
		1 0 sp_assert
	} elif dup Tok.equ = {
		Inst.equ 0 ir
		2 1 sp_assert
	} elif dup Tok.nequ = {
		Inst.nequ 0 ir
		2 1 sp_assert
	} elif dup Tok.gt = {
		Inst.gt 0 ir
		2 1 sp_assert
	} elif dup Tok.lt = {
		Inst.lt 0 ir
		2 1 sp_assert
	} elif dup Tok.gte = {
		Inst.gte 0 ir
		2 1 sp_assert
	} elif dup Tok.lte = {
		Inst.lte 0 ir
		2 1 sp_assert
	} elif dup Tok.s_gt = {
		Inst.s_gt 0 ir
		2 1 sp_assert
	} elif dup Tok.s_lt = {
		Inst.s_lt 0 ir
		2 1 sp_assert
	} elif dup Tok.s_gte = {
		Inst.s_gte 0 ir
		2 1 sp_assert
	} elif dup Tok.s_lte = {
		Inst.s_lte 0 ir
		2 1 sp_assert
	} else {
		drop false ret
	}
	drop
	true
}

; ( bool )
fn parse.complex_token? 0 1 {
	pos token_stream[] rToken.tok
	dup Tok.string_lit = if {
		Inst.push_str pos token_stream[] rToken.data ir
		2 sp_push
	} elif dup Tok.w8 = {
		Inst.w8 0 ir
		2 0 sp_assert
	} elif dup Tok.w16 = {
		Inst.w16 0 ir
		2 0 sp_assert
	} elif dup Tok.w32 = {
		Inst.w32 0 ir
		2 0 sp_assert
	} elif dup Tok.w64 = {
		Inst.w64 0 ir
		2 0 sp_assert
	} elif dup Tok.r8 = {
		Inst.r8 0 ir
		1 1 sp_assert
	} elif dup Tok.r16 = {
		Inst.r16 0 ir
		1 1 sp_assert
	} elif dup Tok.r32 = {
		Inst.r32 0 ir
		1 1 sp_assert
	} elif dup Tok.r64 = {
		Inst.r64 0 ir
		1 1 sp_assert
	} elif dup Tok.trap_breakpoint = {
		Inst.trap_breakpoint 0 ir
		1 1 sp_assert
	} elif dup Tok.syscall0 = {
		Inst.syscall0 0 ir
		1 1 sp_assert
	} elif dup Tok.syscall1 = {
		Inst.syscall1 0 ir
		2 1 sp_assert
	} elif dup Tok.syscall2 = {
		Inst.syscall2 0 ir
		3 1 sp_assert
	} elif dup Tok.syscall3 = {
		Inst.syscall3 0 ir
		4 1 sp_assert
	} elif dup Tok.syscall4 = {
		Inst.syscall4 0 ir
		5 1 sp_assert
	} elif dup Tok.syscall5 = {
		Inst.syscall5 0 ir
		6 1 sp_assert
	} elif dup Tok.syscall6 = {
		Inst.syscall6 0 ir
		7 1 sp_assert
	} elif dup Tok.argc = {
		Inst.push_argc 0 ir
		1 sp_push
	} elif dup Tok.argv = {
		Inst.push_argv 0 ir
		1 sp_push
	} elif dup Tok.envp = {
		Inst.push_envp 0 ir
		1 sp_push
	} else {
		drop false ret
	}
	drop
	true
}


; ( -- is_early_ret )
fn parse.slurp_early_ret 0 1 {
	reserve is_early_ret 1
	is_early_ret false w8

	while
		scope_context.len 0 > if {
			scope_context.top rScope.typ ScopeTyp.early_ret = if {
				scope_context.top rScope.idx

				dup 0 != if {
					dup pos -- != if {
						++ 'unreachable code' error.Tok 
					} else {
						drop
					}
				} else {
					drop
				}
				
				true
			} else {
				false
			}
		} else {
			false
		}
	{
		is_early_ret true w8
		scope_context.len -- pop scope_context.len
	}

	is_early_ret r8
}

fn parse.handle_close_r_cb {
	reserve is_early_ret 1
	is_early_ret parse.slurp_early_ret w8

	reserve scope sizeof(Scope)
	scope scope_context.pop_into_ptr

	scope rScope.var_scope pop var_context.len

	scope rScope.typ
	dup ScopeTyp.function = if {
		function_context Function.end_inst ir_stream.len w32
		Inst.fn_leave function_context_idx ir

		is_early_ret r8 ! if {
			sp.len function_context rFunction.retc > if {
				function_context rFunction.start_inst.idx
				'unhandled data on the stack' error_st.Tok
			} elif sp.len function_context rFunction.retc < {
				function_context rFunction.start_inst.idx
				'not enough values on the stack on function return' error_st.Tok
			}
		}

		0    pop sp.len
		NULL pop function_context
		-1   pop function_context_idx

		is_early_ret false w8
	} elif dup ScopeTyp.while_block_scope = {
		reserve while_header sizeof(Scope)
		while_header scope_context.pop_into_ptr

		Inst.do_jmp while_header rScope.label_id ir
		Inst.label  scope        rScope.label_id ir
	} elif dup ScopeTyp.scope = {
		; nop
	} elif dup ScopeTyp.checked_scope = {
		is_early_ret r8 if {
			scope rScope.sp pop sp.len
		}
		sp.len scope rScope.sp > if {
			scope rScope.idx
				'scope assertation failed, more values on the stack than expected (TODO: write count)'
			error_st.Tok
		} elif sp.len scope rScope.sp < {
			scope rScope.idx
				'scope assertation failed, less values on the stack than expected (TODO: write count)'
			error_st.Tok
		}
	} elif dup ScopeTyp.if_block = {
		pos 1 + token_stream.len <
		pos 1 + token_stream[] rToken.tok Tok.else_block =
		& if {
			pos ++ pop pos

			auto lbl 1
			label_allocate pop lbl

			; (typ sp sp2 idx label_id label_id2 var_scope)
				ScopeTyp.else_block_scope
				sp.len
				is_early_ret r8 if {
					scope rScope.sp		
				} else {
					sp.len
				}
				pos
				lbl
				UINT32_MAX
				var_context.len
			scope_context<<

			scope rScope.sp pop sp.len
			Inst.do_jmp lbl ir

			pos ++ pop pos
			pos token_stream.len >= if {
				pos 1 - 'unexpected EOF when parsing else statement' error.Tok
			}
			pos token_stream[] rToken.tok Tok.l_cb != if {
				pos 'a scope must come after an else statement' error.Tok
			}
			Inst.label scope rScope.label_id ir
		} elif
			pos 1 + token_stream.len <
			pos 1 + token_stream[] rToken.tok Tok.elif_block =
		& {
			pos ++ pop pos

			; (typ sp sp2 idx label_id label_id2 var_scope)
				ScopeTyp.elif_block
				scope rScope.sp
				is_early_ret r8 if {
					scope rScope.sp		
				} else {
					sp.len
				}
				pos
				label_allocate
				scope rScope.label_id2
				var_context.len
			scope_context<<

			scope rScope.sp pop sp.len
			Inst.do_jmp scope rScope.label_id2 ir
			Inst.label  scope rScope.label_id  ir
		} else {
			is_early_ret r8 if {
				scope rScope.sp pop sp.len
			}
			scope rScope.sp sp.len != if {
				pos 'the stack must remain the same with single branches' error_st.Tok
			}
			Inst.label scope rScope.label_id ir
		}
	} elif dup ScopeTyp.elif_block_scope = {
		pos 1 + token_stream.len <
			pos 1 + token_stream[] rToken.tok
			dup  Tok.elif_block =
			swap Tok.else_block =
		| &
		if {
			pos ++ pop pos

			; (typ sp sp2 idx label_id label_id2 var_scope)
				pos token_stream[] rToken.tok
				dup Tok.elif_block = if {
					ScopeTyp.elif_block
				} elif dup Tok.else_block = {
					ScopeTyp.else_block_scope
				} else {
					0 0 assert -> 'unreachable'
				}
				swap drop

				scope rScope.sp
				scope rScope.sp2
				pos
				label_allocate
				scope rScope.label_id2
				var_context.len
			scope_context<<

			is_early_ret r8 if {
				scope rScope.sp2 pop sp.len
			}
			scope rScope.sp2 sp.len != if {
				pos 'the stack must remain the same each with else if branch' error_st.Tok
			}
			scope rScope.sp pop sp.len

			Inst.do_jmp scope rScope.label_id2 ir
			Inst.label  scope rScope.label_id  ir

			pos token_stream[] rToken.tok Tok.else_block = if {
				pos ++ pop pos
				pos token_stream.len >= if {
					pos 1 - 'unexpected EOF when parsing else statement' error.Tok
				}
				pos token_stream[] rToken.tok Tok.l_cb != if {
					pos 'a scope must come after an else statement' error.Tok
				}
			}
		} else {
			is_early_ret r8 if {
				scope rScope.sp2 pop sp.len
			}
			scope rScope.sp2 sp.len != if {
				pos 'the stack must remain the same with single branches' error_st.Tok
			}
			Inst.label scope rScope.label_id  ir
			Inst.label scope rScope.label_id2 ir
		}
	} elif dup ScopeTyp.else_block_scope = {
		is_early_ret r8 if {
			scope rScope.sp2 pop sp.len
		}
		sp.len scope rScope.sp2 > if {
			scope rScope.idx
				'unbalanced stack on both if and else branches, else has more than expected (TODO: write count)'
			error_st.Tok
		} elif sp.len scope rScope.sp2 < {
			scope rScope.idx
				'unbalanced stack on both if and else branches, else has less than expected (TODO: write count)'
			error_st.Tok
		}
		Inst.label scope rScope.label_id ir
		scope rScope.label_id2 UINT32_MAX != if {
			Inst.label scope rScope.label_id2 ir
		}
	} else {
		scope rScope.typ putuln
		
		scope rScope.idx
			'block expects body, an unhandled elif or while keyword may be the culprit'
		error.Tok
	}
	drop

	is_early_ret r8 if {
		parse.push_early_ret
	}
}

fn parse.handle_open_l_cb {
	parse.slurp_early_ret drop

	scope_context.len 1 > if {	
		scope_context.top rScope.typ
		dup ScopeTyp.while_block = if {
			sp.len 0 = if {
				pos 'no value on stack to consume for while header' error.Tok
			}
			sp.len -- pop sp.len
			auto lbl 1
			label_allocate pop lbl

			; (typ sp sp2 idx label_id label_id2 var_scope)
				ScopeTyp.while_block_scope
				sp.len
				0
				pos
				lbl
				0
				var_context.len
			scope_context<<

			Inst.do_cond_jmp lbl ir
		} elif dup ScopeTyp.elif_block = {
			reserve scope sizeof(Scope)
			scope scope_context.pop_into_ptr

			sp.len 0 = if {
				pos 'no value on stack to consume for else if statement' error.Tok
			}
			sp.len -- pop sp.len
			auto lbl 1
			label_allocate pop lbl

			; (typ sp sp2 idx label_id label_id2 var_scope)
				ScopeTyp.elif_block_scope
				scope rScope.sp
				scope rScope.sp2
				pos
				lbl
				scope rScope.label_id2
				var_context.len
			scope_context<<

			Inst.do_cond_jmp lbl ir
		} else {
			parse.push_empty_scope
		}
		drop
	} else {
		parse.push_empty_scope
	}
}

; ( ScopeTyp -- idx? )
fn parse.locate_scope 1 1 {
	auto scopetyp 1 pop scopetyp

	scope_context.len 0 = if {
		-1 ret
	}

	auto f 1 false pop f

	scope_context.len 1 -
	while 1 {
		dup scope_context[] rScope.typ
		scopetyp = if {
			ret
		}

		dup 0 = if {
			break
		}
		--
	}
	drop

	-1
}

fn parse.handle_name {
	auto str   2 pos token_stream[] rToken.data string_view_to_str pop str
	auto f_idx 1
	auto found 1 false pop found

	str is_function_name pop f_idx
	f_idx -1 != if {
		Inst.fn_call f_idx ir

		function_context_idx f_idx = if {
			function_context Function.forbid_inline 1 w8
			function_context rFunction.attributes FnAttribute.inline FnAttribute.is_set if {
				pos 'inline functions cannot call themselves' error.Tok
			}
			function_context Function.tail_r_label label_allocate w32
		}

		f_idx functions[] rFunction.attributes
		FnAttribute.noreturn FnAttribute.is_set if {
			parse.push_early_ret_with_pos
		}

		sp.len
		f_idx functions[] rFunction.argc
		< if {
			pos 'not enough values to consume for function call' error_st.Tok
		}

		f_idx functions[] rFunction.argc
		f_idx functions[] rFunction.retc
		sp_assert

		true pop found
	}
	found ! if {
		str 
			0 scope_context[] rScope.var_scope ; fn scope only
		search_variable_name pop f_idx

		f_idx -1 != if {
			auto var 1
			f_idx var_context[] pop var

			var rVariable.typ
			dup VarTyp.buffer = if {
				Inst.push_local_addr var rVariable.a_sp ir
				1 sp_push
			} elif dup VarTyp.stack = {
				auto to_push 1
				var rVariable.size 8 / pop to_push

				Inst.push_local_stack_var
					to_push 32 <<
					var rVariable.a_sp |
				ir

				to_push sp_push
			} elif dup VarTyp.constant = {
				0 assert -> 'unimplemented'
			} else {
				0 assert
			}
			drop
			true pop found
		}
	}
	found ! if {
		str search_variable_name_global pop f_idx

		f_idx -1 != if {
			auto var 1
			f_idx var_context[] pop var

			var rVariable.typ
			dup VarTyp.buffer = if {
				Inst.push_global_var_name f_idx ir
				1 sp_push
			} elif dup VarTyp.stack = {
				Inst.push_global_stack_var f_idx ir
				var rVariable.size 8 / sp_push
			} elif dup VarTyp.constant = {
				0 assert -> 'unimplemented'
			} else {
				0 assert -> 'unreachable'
			}
			drop
			true pop found
		}
	}
	found ! if {
		pos 'unknown function or variable' error.Tok
	}
}

fn parse.fn_complex_body_tokens {
	pos token_stream[] rToken.tok

	dup dup Tok.pop = swap Tok.addr = | if {
		0 assert -> 'unimplemented'
	} elif dup Tok.name = {
		parse.handle_name
	} elif dup Tok.if_block = {
		sp.len 0 = if {
			pos 'no value on stack to consume for if statement' error.Tok
		}
		sp.len -- pop sp.len

		auto lbl 1 label_allocate pop lbl

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.if_block
			sp.len
			0
			pos
			lbl
			label_allocate
			var_context.len
		scope_context<<

		Inst.do_cond_jmp lbl ir
		
		Tok.l_cb parse.expect? ! if {
			pos 'a scope must come after an if statement' error.Tok
		}
	} elif dup Tok.while_block = {
		auto lbl 1
		label_allocate pop lbl

		Inst.label lbl ir

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.while_block
			sp.len
			0
			pos
			lbl
			0
			var_context.len
		scope_context<<
	} elif dup Tok.break_block = {
		scope_context.len 0 = if {
			pos 'not inside while loop body' error.Tok
		}
		ScopeTyp.while_block_scope parse.locate_scope dup -1 = if {
			pos 'not inside while loop body' error.Tok
		}
		Inst.do_jmp swap scope_context[] rScope.label_id ir
		parse.push_early_ret_with_pos
	} elif dup Tok.continue_block = {
		scope_context.len 0 = if {
			pos 'not inside while loop body' error.Tok
		}
		ScopeTyp.while_block parse.locate_scope dup -1 = if {
			pos 'not inside while loop body' error.Tok
		}
		; dup -- scope_context[] dup rScope.typ ScopeTyp.while_block = assert -> 'TODO: zero support for nested while loops or loops with complex blocks inside its header'
		; TODO: still a todo...
		Inst.do_jmp swap scope_context[] rScope.label_id ir
		parse.push_early_ret_with_pos
	} elif dup Tok.l_cb = {
		parse.handle_open_l_cb
	} elif dup Tok.r_cb = {
		parse.handle_close_r_cb
	} elif dup Tok.ret = {
		Inst.fn_leave function_context_idx ir
		sp.len function_context rFunction.retc > if {
			pos 'unhandled data on the stack for early return' error_st.Tok
		} elif sp.len function_context rFunction.retc < {
			pos 'not enough values on the stack on early return' error_st.Tok
		}
		0 pop sp.len
		parse.push_early_ret_with_pos
	} elif dup Tok.arrw = {
		auto arrw_c 1
		pos pop arrw_c

		Tok.number_lit parse.expect? ! if {
			pos 'a number must appear after the arrow assert operator' error.Tok
		}

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.checked_scope
			pos token_stream[] rToken.data sp.len +
			0
			arrw_c
			0
			0
			var_context.len
		scope_context<<

		Tok.l_cb parse.expect? ! if {
			pos 'a scope must come after the arrow assert operator' error.Tok
		}
	} else {
		; TODO:
		;     elif -> cannot start elif without if
		;     fn   -> no define function inside function
		0 assert -> 'unimplemented'
	}
	drop
}

; ( str len -- bool )
fn parse.is_scoped_var 2 1 {
	; (str len)
	scope_context.len 0 > if {
		scope_context.top rScope.var_scope
	} else {
		0
	}
	; (str len search_p)
	search_variable_name -1 !=
}

fn parse.any_variable {
	auto typ  1
	auto rs_c 1 pos pop rs_c

	pos token_stream[] rToken.tok
	dup Tok.reserve = if {
		VarTyp.buffer
	} elif dup Tok.auto = {
		VarTyp.stack
	} else {
		0
		; does not handle constants.
		0 assert -> 'unreachable'
	}
	pop typ
	drop

	Tok.name parse.expect? ! if {
		pos 'expected variable name' error.Tok
	}

	auto str 2
		pos token_stream[] rToken.data string_view_to_str
	pop str

	parse.next_eof? ! if {
		pos 'unexpected EOF in variable declaration' error.Tok
	}
	; (Tok)
	dup dup Tok.name = swap Tok.l_cb = | if {
		0
		0 assert -> 'unimplemented'
	} elif dup Tok.number_lit = {
		pos token_stream[] rToken.data
		typ VarTyp.stack = if {
			dup 0 = if {
				pos 'auto variables cannot have a size of zero' error.Tok
			}
			8 *
		}
	} else {
		pos 'expected size in bytes, constant name or constant expression' error.Tok
		0
		; noreturn function
	}
	auto size 1 pop size
	drop

	str parse.is_scoped_var if {
		rs_c ++ 'duplicate variable name' error.Tok
	}

	; `function_context NULL =` means toplevel

	; (typ size a_sp idx name)
		typ
		size
		function_context NULL != if {
			function_context rFunction.a_sp
		} else {
			0
		}
		rs_c
		rs_c ++ token_stream[] rToken.data
	var_context<<

	function_context NULL != if {
		function_context Function.a_sp
			function_context rFunction.a_sp size +
		w32
		function_context Function.forbid_inline 1 w8
	}
}

fn stas.parse {
	-1 pop main_fn_idx
	0  pop pos

	while pos token_stream.len < {
		pos token_stream[] rToken.tok
		dup dup Tok.reserve = swap Tok.auto = | if {
			parse.any_variable
		} elif dup Tok.const = {
			0 assert -> 'unimplemented'
		} else {
			scope_context.len 0 = if {
				pos token_stream[] rToken.tok

				dup Tok.fn_decl = if {
					parse.fn_decl
				} elif dup Tok.sub = {
					Tok.name parse.expect? ! if {
						pos "expected name as function attribute" error.Tok
					}
					pos token_stream[]
					rToken.data string_view_to_str FnAttribute.from_str? ! if {
						pos "unknown function attribute" error.Tok
					}
					function_attributes | pop function_attributes
				} else {
					pos "unknown toplevel token" error.Tok
				}
				drop
			} else {
				parse.basic_token? ! if {
					parse.fn_complex_body_tokens
				}
			}
		}
		drop

		pos ++ pop pos
	}

	sp.len 0 = assert

;	scope_context.len putuln
;	0 scope_context[] rScope.idx "ee" error.Tok
	function_context NULL != if {
		token_stream.len -- "unexpected EOF when parsing function, scopes may be unclosed" error.Tok	
	}
	scope_context.len 0 = assert
}