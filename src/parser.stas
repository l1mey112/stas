auto label_c 1

fn label_allocate 0 1 {
	label_c dup ++ pop label_c
}

auto main_fn_idx          1
auto function_context     1
auto function_context_idx 1
auto function_attributes  1

; ( str len -- idx )
fn is_function_name 2 1 {
	functions.len 0 = if {
		drop drop
		UINT64_MAX
		ret
	}

	auto lit 2 pop lit

	0
	while dup functions.len < {
		dup functions[] rFunction.name string_view_to_str
		lit streq if {
			ret
		}
		++
	}
	drop
	UINT64_MAX
}

; ( string_view -- idx )
fn search_variable_name 1 1 {
	var_context.len 0 = if {
		drop
		UINT64_MAX
		ret
	}

	auto lit 2
	string_view_to_str pop lit

	var_context.len 1 -
	while 1 {
		dup var_context[] rVariable.name string_view_to_str
		lit streq if {
			ret
		}

		dup 0 = if {
			break
		}
		--
	}
	drop
	UINT64_MAX
}

fn parse.push_empty_scope {
	; (typ sp sp2 idx label_id label_id2 var_scope)
		ScopeTyp.scope
		sp.len
		0
		pos
		0
		0
		var_context.len
	scope_context<<
}

fn parse.push_early_ret {
	scope_context.len sizeof(Scope) * scope_context +
	dup Scope.typ ScopeTyp.early_ret w32
	    Scope.idx 0                  w32

	scope_context.len ++ pop scope_context.len
	scope_context.len scope_context.cap < assert
}

fn parse.push_early_ret_with_pos {
	scope_context.len sizeof(Scope) * scope_context +
	dup Scope.typ ScopeTyp.early_ret w32
	    Scope.idx pos                w32

	scope_context.len ++ pop scope_context.len
	scope_context.len scope_context.cap < assert
}

; ( Tok -- bool )
fn parse.lookahead? 1 1 {
	pos ++
	dup token_stream.len >= if {
		drop drop false ret
	}
	token_stream[] rToken.tok =
}

; ( Tok -- bool )
fn parse.expect? 1 1 {
	; `pos` will be unchanged on EOF
	pos ++
	dup token_stream.len >= if {
		drop drop false ret
	}
	token_stream[] rToken.tok =
	pos ++ pop pos
}

; ( -- Tok bool )
fn parse.next_eof? 0 2 {
	pos ++ pop pos
	pos token_stream.len >= if {
		-1 false ret
	}
	pos token_stream[] rToken.tok
	true
}

fn parse.fn_decl {
	auto _argc 1
	auto _retc 1
	auto fn_c  1 pos pop fn_c
	
	Tok.name parse.expect? ! if {
		pos 'function name must not be an intrinsic' error.Tok
	}

	auto name 2
		pos token_stream[] rToken.data string_view_to_str
	pop name
	
	name drop r8 `_` = if {
		pos 'a function name cannot begin with an an underscore' error.Tok
	}
	name is_function_name UINT64_MAX != if {
		pos 'duplicate function name' error.Tok
	}
	
	parse.next_eof? ! if {
		pos 'unknown token in function declaration' error.Tok
	}
	dup Tok.l_cb = if {
		0 pop _argc
		0 pop _retc
	} elif dup Tok.number_lit = {
		Tok.number_lit parse.expect? ! if {
			pos 'function return and argument counts must be numbers' error.Tok
		}

		fn_c 2 + token_stream[] rToken.data pop _argc
		fn_c 3 + token_stream[] rToken.data pop _retc

		Tok.l_cb parse.expect? ! if {
			fn_c 'new scope must proceed after function header' error.Tok
		}
	} else {
		pos 'unknown token in function declaration' error.Tok
	}
	drop

;	function_attributes FnAttribute.is_conflict if {
;		fn_c 'function attributes conflict' error.Tok
;	}

	; TODO: search variable idx, pass stopping value of zero for scope

;	sv is_toplevel_name_bool if {
;		fn_c 1 + 'function name already exists as variable name' error.Tok
;	}


	functions.len sizeof(Function) * functions + pop function_context
	functions.len                                pop function_context_idx
		_argc
		_retc
		fn_c ++ token_stream[] rToken.data
		ir_stream.len
		0 ; end_inst
		0 ; a_sp
		name 'main' streq if {
			; TODO: main function is not inlinable
			;	function_attributes FnAttribute.inline FnAttribute.is_set if {
			;		fn_c 'the main function is not inlinable' error.Tok
			;	}

			_argc 0 !=
			_retc 0 != | if {
				fn_c 'the main function must accept and return zero values' error.Tok
			}

			functions.len pop main_fn_idx
			1 1 ; is_used, forbid_inline
		} else {
			0 ; is_used

			; TODO: forbid_inline
			;	function_attributes FnAttribute.noinline FnAttribute.is_set if {
			;		1
			;	} else {
			;		0
			;	}

			0 ; forbid inline
		}
		NULL ; TODO: function_attributes
	functions<<

	fn_c Inst.fn_prelude function_context_idx ir_p
	_argc fn_c sp_push_p

	sp.len 0 = assert
	; 0 pop function_attributes

	; (typ sp sp2 idx label_id label_id2 var_scope)
		ScopeTyp.function
		0
		0
		pos
		0
		0
		var_context.len
	scope_context<<
}

; ( bool )
fn parse.basic_token? 0 1 {
	pos token_stream[] rToken.tok

	; fn ir   (inst data)
	; fn ir_p (pos inst data)

	dup Tok._assert = if {
		0 assert -> 'unimplemented'
	;	parse.assert
	} elif dup Tok.number_lit = {
		Inst.push_num pos token_stream[] rToken.data ir
		1 sp_push
	} elif dup Tok.plus = {
		Inst.plus 0 ir
		2 1 sp_assert
	} elif dup Tok.sub = {
		Inst.sub 0 ir
		2 1 sp_assert
	} elif dup Tok.mul = {
		Inst.mul 0 ir
		2 1 sp_assert
	} elif dup Tok.div = {
		Inst.div 0 ir
		2 1 sp_assert
	} elif dup Tok.mod = {
		Inst.mod 0 ir
		2 1 sp_assert
	} elif dup Tok.inc = {
		Inst.inc 0 ir
		1 1 sp_assert
	} elif dup Tok.dec = {
		Inst.dec 0 ir
		1 1 sp_assert
	} elif dup Tok.divmod = {
		Inst.divmod 0 ir
		2 2 sp_assert
	} elif dup Tok.shr = {
		Inst.shr 0 ir
		2 1 sp_assert
	} elif dup Tok.shl = {
		Inst.shl 0 ir
		2 1 sp_assert
	} elif dup Tok.b_and = {
		Inst.b_and 0 ir
		2 1 sp_assert
	} elif dup Tok.b_or = {
		Inst.b_or 0 ir
		2 1 sp_assert
	} elif dup Tok.b_not = {
		Inst.b_not 0 ir
		1 1 sp_assert
	} elif dup Tok.not = {
		Inst.not 0 ir
		1 1 sp_assert
	} elif dup Tok.b_xor = {
		Inst.b_xor 0 ir
		2 1 sp_assert
	} elif dup Tok.swap = {
		Inst.swap 0 ir
		2 sp_has
			sp.pop
			sp.pop
			swap
			sp<<
			sp<<
	} elif dup Tok.dup = {
		Inst.dup 0 ir
		1 sp_has
		sp.top sp<<
	} elif dup Tok.over = {
		Inst.over 0 ir
		2 sp_has
		sp.len 2 - sp[] sp<<
	} elif dup Tok.over2 = {
		Inst.over2 0 ir
		3 sp_has
		sp.len 3 - sp[] sp<<
	} elif dup Tok.rot = {
		Inst.rot 0 ir
		3 sp_has
			sp.pop
			sp.pop
			sp.pop
			rot rot
			sp<<
			sp<<
			sp<<
	} elif dup Tok.rot4 = {
		Inst.rot4 0 ir
		4 sp_has
			sp.pop
			sp.pop
			sp.pop
			sp.pop
			rot4 rot4 rot4
			sp<<
			sp<<
			sp<<
			sp<<
	} elif dup Tok.drop = {
		Inst.drop 0 ir
		1 0 sp_assert
	} elif dup Tok.equ = {
		Inst.equ 0 ir
		2 1 sp_assert
	} elif dup Tok.nequ = {
		Inst.nequ 0 ir
		2 1 sp_assert
	} elif dup Tok.gt = {
		Inst.gt 0 ir
		2 1 sp_assert
	} elif dup Tok.lt = {
		Inst.lt 0 ir
		2 1 sp_assert
	} elif dup Tok.gte = {
		Inst.gte 0 ir
		2 1 sp_assert
	} elif dup Tok.lte = {
		Inst.lte 0 ir
		2 1 sp_assert
	} elif dup Tok.s_gt = {
		Inst.s_gt 0 ir
		2 1 sp_assert
	} elif dup Tok.s_lt = {
		Inst.s_lt 0 ir
		2 1 sp_assert
	} elif dup Tok.s_gte = {
		Inst.s_gte 0 ir
		2 1 sp_assert
	} elif dup Tok.s_lte = {
		Inst.s_lte 0 ir
		2 1 sp_assert
	} else {
		drop false ret
	}
	drop
	true
}

; ( -- bool(is_early_ret) )
fn parse.slurp_early_ret 0 1 {
	reserve is_early_ret 1
	is_early_ret false w8

	while
		scope_context.len 0 > if {
			scope_context.top rScope.typ ScopeTyp.early_ret = if {
				scope_context.top rScope.idx

				dup 0 != if {
					dup pos -- != if {
						++ 'unreachable code' error.Tok 
					} else {
						drop
					}
				} else {
					drop
				}
				
				true
			} else {
				false
			}
		} else {
			false
		}
	{
		is_early_ret true w8
		scope_context.len -- pop scope_context.len
	}

	is_early_ret r8
}

fn parse.handle_close_r_cb {
	reserve is_early_ret 1
	is_early_ret parse.slurp_early_ret w8

	reserve scope sizeof(Scope)
	scope scope_context.pop_into_ptr

	scope rScope.var_scope pop var_context.len

	scope rScope.typ
	dup ScopeTyp.function = if {
		function_context Function.end_inst ir_stream.len w32
		Inst.fn_leave function_context_idx ir

		is_early_ret r8 ! if {
			-> 0 {
				sp.len function_context rFunction.retc > if {
					function_context rFunction.start_inst.idx
					'unhandled data on the stack' error_st.Tok
				} elif sp.len function_context rFunction.retc < {
					function_context rFunction.start_inst.idx
					'not enough values on the stack on function return' error_st.Tok
				}
			}
		}

		0          pop sp.len
		0          pop var_context.len
		NULL       pop function_context
		UINT64_MAX pop function_context_idx
	} elif dup ScopeTyp.while_block_scope = {
		reserve while_header sizeof(Scope)
		while_header scope_context.pop_into_ptr

		Inst.do_jmp while_header rScope.label_id ir
		Inst.label  scope        rScope.label_id ir
	} elif dup ScopeTyp.scope = {
		; nop
	} elif dup ScopeTyp.checked_scope = {
		is_early_ret r8 if {
			scope rScope.sp pop sp.len
		}
		sp.len scope rScope.sp > if {
			scope rScope.idx
				'scope assertation failed, more values on the stack than expected (TODO: write count)'
			error_st.Tok
		} elif sp.len scope rScope.sp < {
			scope rScope.idx
				'scope assertation failed, less values on the stack than expected (TODO: write count)'
			error_st.Tok
		}
	} elif dup ScopeTyp.if_block = {
		pos 1 + token_stream.len <
		pos 1 + token_stream[] rToken.tok Tok.else_block =
		& if {
			pos ++ pop pos

			auto lbl 1
			label_allocate pop lbl

			; (typ sp sp2 idx label_id label_id2 var_scope)
				ScopeTyp.else_block_scope
				sp.len
				is_early_ret r8 if {
					scope rScope.sp		
				} else {
					sp.len
				}
				pos
				lbl
				UINT32_MAX
				var_context.len
			scope_context<<

			scope rScope.sp pop sp.len
			Inst.do_jmp lbl ir

			pos ++ pop pos
			pos token_stream.len >= if {
				pos 1 - 'unexpected EOF when parsing else statement' error.Tok
			}
			pos token_stream[] rToken.tok Tok.l_cb != if {
				pos 'a scope must come after an else statement' error.Tok
			}
			Inst.label scope rScope.label_id ir
		} elif
			pos 1 + token_stream.len <
			pos 1 + token_stream[] rToken.tok Tok.elif_block =
		& {
			pos ++ pop pos

			; (typ sp sp2 idx label_id label_id2 var_scope)
				ScopeTyp.elif_block
				scope rScope.sp
				is_early_ret r8 if {
					scope rScope.sp		
				} else {
					sp.len
				}
				pos
				label_allocate
				scope rScope.label_id2
				var_context.len
			scope_context<<

			scope rScope.sp pop sp.len
			Inst.do_jmp scope rScope.label_id2 ir
			Inst.label  scope rScope.label_id  ir
		} else {
			is_early_ret r8 if {
				scope rScope.sp pop sp.len
			}
			scope rScope.sp sp.len != if {
				pos 'the stack must remain the same with single branches' error_st.Tok
			}
			Inst.label scope rScope.label_id ir
		}
	} elif dup ScopeTyp.elif_block_scope = {
		pos 1 + token_stream.len <
			pos 1 + token_stream[] rToken.tok
			dup  Tok.elif_block =
			swap Tok.else_block =
		| &
		if {
			pos ++ pop pos

			; (typ sp sp2 idx label_id label_id2 var_scope)
				pos token_stream[] rToken.tok
				dup Tok.elif_block = if {
					ScopeTyp.elif_block
				} elif dup Tok.else_block = {
					ScopeTyp.else_block_scope
				} else {
					0 0 assert -> 'unreachable'
				}
				swap drop

				scope rScope.sp
				scope rScope.sp2
				pos
				label_allocate
				scope rScope.label_id2
				var_context.len
			scope_context<<

			is_early_ret r8 if {
				scope rScope.sp2 pop sp.len
			}
			scope rScope.sp2 sp.len != if {
				pos 'the stack must remain the same each with else if branch' error_st.Tok
			}
			scope rScope.sp pop sp.len

			Inst.do_jmp scope rScope.label_id2 ir
			Inst.label  scope rScope.label_id  ir

			pos token_stream[] rToken.tok Tok.else_block = if {
				pos ++ pop pos
				pos token_stream.len >= if {
					pos 1 - 'unexpected EOF when parsing else statement' error.Tok
				}
				pos token_stream[] rToken.tok Tok.l_cb != if {
					pos 'a scope must come after an else statement' error.Tok
				}
			}
		} else {
			is_early_ret r8 if {
				scope rScope.sp2 pop sp.len
			}
			scope rScope.sp2 sp.len != if {
				pos 'the stack must remain the same with single branches' error_st.Tok
			}
			Inst.label scope rScope.label_id  ir
			Inst.label scope rScope.label_id2 ir
		}
	} elif dup ScopeTyp.else_block_scope = {
		is_early_ret r8 if {
			scope rScope.sp2 pop sp.len
		}
		sp.len scope rScope.sp2 > if {
			scope rScope.idx
				'unbalanced stack on both if and else branches, else has more than expected (TODO: write count)'
			error_st.Tok
		} elif sp.len scope rScope.sp2 < {
			scope rScope.idx
				'unbalanced stack on both if and else branches, else has less than expected (TODO: write count)'
			error_st.Tok
		}
		Inst.label scope rScope.label_id ir
		scope rScope.label_id2 UINT32_MAX != if {
			Inst.label scope rScope.label_id2 ir
		}
	} else {
		scope rScope.typ putuln
		
		scope rScope.idx
			'block expects body, an unhandled elif or while keyword may be the culprit'
		error.Tok
	}
	drop

	is_early_ret r8 if {
		parse.push_early_ret
	}
}

fn parse.handle_open_l_cb {
	parse.slurp_early_ret drop

	scope_context.top rScope.typ
	dup ScopeTyp.while_block = if {
		sp.len 0 = if {
			pos 'no value on stack to consume for while header' error.Tok
		}
		sp.len -- pop sp.len
		auto lbl 1
		label_allocate pop lbl

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.while_block_scope
			sp.len
			0
			pos
			lbl
			0
			var_context.len
		scope_context<<

		Inst.do_cond_jmp lbl ir
	} elif dup ScopeTyp.elif_block = {
		reserve scope sizeof(Scope)
		scope scope_context.pop_into_ptr

		sp.len 0 = if {
			pos 'no value on stack to consume for else if statement' error.Tok
		}
		sp.len -- pop sp.len
		auto lbl 1
		label_allocate pop lbl

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.elif_block_scope
			scope rScope.sp
			scope rScope.sp2
			pos
			lbl
			scope rScope.label_id2
			var_context.len
		scope_context<<

		Inst.do_cond_jmp lbl ir
	} else {
		parse.push_empty_scope
	}
	drop
}

; ( ScopeTyp -- idx? )
fn parse.locate_scope 1 1 {
	auto scopetyp 1 pop scopetyp

	scope_context.len 0 = if {
		-1 ret
	}

	auto f 1 false pop f

	scope_context.len 1 -
	while 1 {
		dup scope_context[] rScope.typ
		scopetyp = if {
			ret
		}

		dup 0 = if {
			break
		}
		--
	}
	drop

	-1
}

fn parse.fn_complex_body_tokens {
	pos token_stream[] rToken.tok

	dup dup dup Tok.reserve = rot Tok.auto = rot Tok.const = | | if {
		0 assert -> 'unimplemented'
	} elif dup dup Tok.pop = swap Tok.addr = | {
		0 assert -> 'unimplemented'
	} elif dup Tok.name = {
		0 assert -> 'unimplemented'
	} elif dup Tok.if_block = {
		sp.len 0 = if {
			pos 'no value on stack to consume for if statement' error.Tok
		}
		sp.len -- pop sp.len

		auto lbl 1 label_allocate pop lbl

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.if_block
			sp.len
			0
			pos
			lbl
			label_allocate
			var_context.len
		scope_context<<

		Inst.do_cond_jmp lbl ir
		
		Tok.l_cb parse.expect? ! if {
			pos 'a scope must come after an if statement' error.Tok
		}
	} elif dup Tok.while_block = {
		auto lbl 1
		label_allocate pop lbl

		Inst.label lbl ir

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.while_block
			sp.len
			0
			pos
			lbl
			0
			var_context.len
		scope_context<<
	} elif dup Tok.break_block = {
		scope_context.len 0 = if {
			pos 'not inside while loop body' error.Tok
		}
		ScopeTyp.while_block_scope parse.locate_scope dup -1 = if {
			pos 'not inside while loop body' error.Tok
		}
		Inst.do_jmp swap scope_context[] rScope.label_id ir
		parse.push_early_ret_with_pos
	} elif dup Tok.continue_block = {
		scope_context.len 0 = if {
			pos 'not inside while loop body' error.Tok
		}
		ScopeTyp.while_block parse.locate_scope dup -1 = if {
			pos 'not inside while loop body' error.Tok
		}
		; dup -- scope_context[] dup rScope.typ ScopeTyp.while_block = assert -> 'TODO: zero support for nested while loops or loops with complex blocks inside its header'
		Inst.do_jmp swap scope_context[] rScope.label_id ir
		parse.push_early_ret_with_pos
	} elif dup Tok.l_cb = {
		parse.handle_open_l_cb
	} elif dup Tok.r_cb = {
		parse.handle_close_r_cb
	} elif dup Tok.ret = {
		Inst.fn_leave function_context_idx ir
		sp.len function_context rFunction.retc > if {
			pos 'unhandled data on the stack for early return' error_st.Tok
		} elif sp.len function_context rFunction.retc < {
			pos 'not enough values on the stack on early return' error_st.Tok
		}
		0 pop sp.len
		parse.push_early_ret_with_pos
	} elif dup Tok.arrw = {
		auto arrw_c 1
		pos pop arrw_c

		Tok.number_lit parse.expect? ! if {
			pos 'a number must appear after the arrow assert operator' error.Tok
		}

		; (typ sp sp2 idx label_id label_id2 var_scope)
			ScopeTyp.checked_scope
			pos token_stream[] rToken.data sp.len +
			0
			arrw_c
			0
			0
			var_context.len
		scope_context<<

		Tok.l_cb parse.expect? ! if {
			pos 'a scope must come after the arrow assert operator' error.Tok
		}
	} else {
		; TODO:
		;     elif -> cannot start elif without if
		;     fn   -> no define function inside function
		0 assert -> 'unimplemented'
	}
	drop
}

fn stas.parse {
	0 pop pos

	while pos token_stream.len < {
		scope_context.len 0 = if {
			pos token_stream[] rToken.tok

			dup Tok.fn_decl = if {
				parse.fn_decl
			} else {
				pos "unknown toplevel token" error.Tok
			}
			drop
		} else {
			parse.basic_token? ! if {
				parse.fn_complex_body_tokens
			}
		}

		pos ++ pop pos
	}
}