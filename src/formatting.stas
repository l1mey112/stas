fn error.start_bold_error 0 0 {
	27 eputc '[1m'  eputs
	27 eputc '[31m' eputs
}

fn error.end_bold_error 0 0 {
	27 eputc '[39m' eputs
	27 eputc '[22m' eputs
}

fn notice.start_bold_notice 0 0 {
	27 eputc '[1m'  eputs
	27 eputc '[33m' eputs
}

fn notice.end_bold_notice 0 0 {
	27 eputc '[39m' eputs
	27 eputc '[22m' eputs
}

fn FileEntry.file_path_sv 1 1 {      }
fn FileEntry.data         1 1 { 8  + }
fn FileEntry.len          1 1 { 16 + }
const sizeof(FileEntry)       { 24   }

fn rFileEntry.file_path_sv 1 1 { FileEntry.file_path_sv r64 }
fn rFileEntry.data         1 1 { FileEntry.data         r64 }
fn rFileEntry.len          1 1 { FileEntry.len          r64 }

const   opened_files.cap     { 128                                  }
const   sizeof(opened_files) { sizeof(FileEntry) opened_files.cap * }
auto    opened_files.len     1
reserve opened_files         sizeof(opened_files)

; (idx -- ptr)
fn opened_files[] 1 1 {
	dup opened_files.len < assert
	sizeof(FileEntry) * opened_files +
}

; (filepath_sv data len)
fn opened_files<< 3 0 {
	opened_files.len sizeof(FileEntry) * opened_files +
	    swap over FileEntry.len          swap w64
	    swap over FileEntry.data         swap w64
	              FileEntry.file_path_sv swap w64

	opened_files.len ++ pop opened_files.len
	opened_files.len opened_files.cap < assert
}

; ( str len str len -- str len )
fn join_path 4 2 {
	auto sv 1

	rot4 rot4 `/` string.trim_len_delim_u8 new_string_view
		pop sv

	sv `/` push_char
	; (str len)
	sv rot push_string_view

	sv string_view_to_str
}

; (str len -- str? len)
fn find_abs_path_of_executable 2 2 {
	auto abc        2 pop abc
	auto search_str 2

	"PATH" getenv
		over NULL != assert -> '\'PATH\' enviroment variable not found'
	pop search_str

	while true {
		search_str `:` string.after_delim_u8.ret_both pop search_str

		search_str drop NULL = if {
			drop drop
			break
		} else {
			abc join_path
			; (str len)

			over 0 access 0 = if {
				ret
			} else {
				drop drop
			}
		}
	}

	NULL 0
}