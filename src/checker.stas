; (Inst *Array32)
fn checker.handle_simple 2 0 {
	auto sp 1 pop sp

	dup Inst.push_num = if {
		1 sp sp_push
	} elif dup Inst.push_str = {
		1 sp sp_push
	} elif dup Inst.push_argc = {
		1 sp sp_push
	} elif dup Inst.push_argv = {
		1 sp sp_push
	} elif dup Inst.push_envp = {
		1 sp sp_push
	} elif dup Inst.plus = {
		2 1 sp sp_assert
	} elif dup Inst.sub = {
		2 1 sp sp_assert
	} elif dup Inst.mul = {
		2 1 sp sp_assert
	} elif dup Inst.div = {
		2 1 sp sp_assert
	} elif dup Inst.mod = {
		2 1 sp sp_assert
	} elif dup Inst.inc = {
		1 1 sp sp_assert
	} elif dup Inst.dec = {
		1 1 sp sp_assert
	} elif dup Inst.divmod = {
		2 2 sp sp_assert
	} elif dup Inst.shr = {
		2 1 sp sp_assert
	} elif dup Inst.shl = {
		2 1 sp sp_assert
	} elif dup Inst.b_and = {
		2 1 sp sp_assert
	} elif dup Inst.b_or = {
		2 1 sp sp_assert
	} elif dup Inst.b_not = {
		1 1 sp sp_assert
	} elif dup Inst.not = {
		1 1 sp sp_assert
	} elif dup Inst.b_xor = {
		2 1 sp sp_assert
	} elif dup Inst.swap = {
		2 sp sp_has
			sp Array32.pop
			sp Array32.pop
			swap
			sp Array32<<
			sp Array32<<
	} elif dup Inst.dup = {
		1 sp sp_has
		sp Array32.top sp Array32<<
	} elif dup Inst.over = {
		2 sp sp_has
		sp rArray32.len 2 - sp Array32[] sp Array32<<
	} elif dup Inst.over2 = {
		3 sp sp_has
		sp rArray32.len 3 - sp Array32[] sp Array32<<
	} elif dup Inst.rot = {
		3 sp sp_has
			sp Array32.pop
			sp Array32.pop
			sp Array32.pop
			rot rot
			sp Array32<<
			sp Array32<<
			sp Array32<<
	} elif dup Inst.rot4 = {
		4 sp sp_has
			sp Array32.pop
			sp Array32.pop
			sp Array32.pop
			sp Array32.pop
			rot4 rot4 rot4
			sp Array32<<
			sp Array32<<
			sp Array32<<
			sp Array32<<
	} elif dup Inst.drop = {
		1 0 sp sp_assert
	} elif dup Inst.equ = {
		2 1 sp sp_assert
	} elif dup Inst.nequ = {
		2 1 sp sp_assert
	} elif dup Inst.gt = {
		2 1 sp sp_assert
	} elif dup Inst.lt = {
		2 1 sp sp_assert
	} elif dup Inst.gte = {
		2 1 sp sp_assert
	} elif dup Inst.lte = {
		2 1 sp sp_assert
	} elif dup Inst.s_gt = {
		2 1 sp sp_assert
	} elif dup Inst.s_lt = {
		2 1 sp sp_assert
	} elif dup Inst.s_gte = {
		2 1 sp sp_assert
	} elif dup Inst.s_lte = {
		2 1 sp sp_assert
	} elif dup Inst._assert = {
		1 0 sp sp_assert
	} elif dup Inst.w8 = {
		2 0 sp sp_assert
	} elif dup Inst.w16 = {
		2 0 sp sp_assert
	} elif dup Inst.w32 = {
		2 0 sp sp_assert
	} elif dup Inst.w64 = {
		2 0 sp sp_assert
	} elif dup Inst.r8 = {
		1 1 sp sp_assert
	} elif dup Inst.r16 = {
		1 1 sp sp_assert
	} elif dup Inst.r32 = {
		1 1 sp sp_assert
	} elif dup Inst.r64 = {
		1 1 sp sp_assert
	} else {
		0 assert -> 'unreachable'
	}
	drop
}

; (lo *Function *Array32 *Array32)
fn check_from 4 0 {
	"------------\n" puts
	auto dup_lut 1 pop dup_lut
	auto dup_arr 1 pop dup_arr
	auto fn_c    1 pop fn_c

	const   sp_arr_default { sizeof(u32) 1024 * }
	reserve sp             sizeof(Array32)
	auto    sp_ptr         1
	
	reserve label_list_data { 256 sizeof(u32) * }
	reserve label_list_arr  sizeof(Array32)

		label_list_data
		sizeof label_list_data
		label_list_arr
	Array32.init_with_buffer_sz_bytes

	auto walk_branch 1 -1 pop walk_branch

	sp_arr_default alloc.alloc pop sp_ptr

		sp_ptr
		sp_arr_default
		sp
	Array32.init_with_buffer_sz_bytes

	dup_arr NULL != if {
		dup_arr sp Array32.dup
	}
	dup_lut NULL != if {
		dup_lut label_list_arr Array32.dup
	}

	auto ir_data 1
	auto ir_pos  1

	pop ir_pos
	while true {
		ir_pos ir_stream[] dup dup rIR.data pop ir_data rIR.idx pop pos rIR.inst
		
		; dup Inst.to_str puts endl

		dup Inst.label = if {
			ir_data label_list_arr Array32<< ; value

			ir_data walk_branch = if {
				-1 pop walk_branch
			}
		} else {
			walk_branch -1 = if {
				pos "eee" notice.Tok
				dup Inst.do_cond_jmp = if {
					1 0 sp sp_assert

					; split in two
					ir_data label_list_arr Array32.in ! if {
						ir_pos ++ fn_c sp label_list_arr check_from
						
						-1 walk_branch = assert
						ir_data pop walk_branch
					}
				} elif dup Inst.do_jmp = {
					ir_data label_list_arr Array32.in ! if {
						-1 walk_branch = assert
						ir_data pop walk_branch
					}
				} elif dup Inst.fn_call = {
					ir_data functions[] pop fn_c

					sp rArray32.len
					fn_c rFunction.argc
					< if {
						pos 'not enough values to consume for function call' sp error_st.Tok
					}

					fn_c rFunction.argc
					fn_c rFunction.retc
					sp sp_assert
				} elif dup Inst.c_fn_call = {
					0 assert -> 'unimplemented'
				} elif dup Inst.fn_prelude = {
					fn_c rFunction.argc sp sp_push
				} elif dup Inst.fn_leave = {
					sp rArray32.len fn_c rFunction.retc > if {
						pos 'unhandled data on the stack on return' sp error_st.Tok
					} elif sp rArray32.len fn_c rFunction.retc < {
						pos 'not enough values on the stack on return' sp error_st.Tok
					}
					break
				} elif dup Inst.asm_invoc = {
					ir_data inline_asms[] pop fn_c

					fn_c rASM.arg_r_len
					fn_c rASM.ret_r_len
					sp sp_assert
				} elif dup Inst.push_local_addr = {
					1 sp sp_push
				} elif dup Inst.pop_local_stack_var = {
					ir_data 32 >> pop ir_data

					sp rArray32.len ir_data < if {
						pos 'not enought values on the stack to pop into an automatic variable' sp error_st.Tok
					}
					sp dup rArray32.len ir_data - wArray32.len
				} elif dup Inst.push_local_stack_var = {
					ir_data 32 >> sp sp_push
				} elif dup Inst.push_global_var_name = {
					1 sp sp_push
				} elif dup Inst.pop_global_stack_var = {
					ir_data var_context[] rVariable.size 8 / pop ir_data

					sp rArray32.len ir_data < if {
						pos 'not enought values on the stack to pop into an automatic variable' sp error_st.Tok
					}
					sp dup rArray32.len ir_data - wArray32.len
				} elif dup Inst.push_global_stack_var = {
					ir_data var_context[] rVariable.size 8 / sp sp_push
				} else {
					dup sp checker.handle_simple
				}
			}
		}
		drop
		ir_pos ++ pop ir_pos
	}
	-1 walk_branch = assert
	sp_ptr alloc.rewind
	">>>>>>>>>>>>\n" puts
}

; (functions[idx])
fn check_function 1 0 {
	functions[] dup rFunction.start_inst swap NULL NULL check_from
}

- noinline
fn stas.check {
	auto pt 1 0 pop pt

	while pt functions.len < {
		pt check_function
		pt ++ pop pt
	}
}