const LF_CH { 10 }
const 0_CH  { 48 }
const 9_CH  { 57 }

; (u8 -- bool)
fn is_whitespace 1 1 {
	dup 13 = if {
		1
	} elif dup 10 = {
		1
	} elif dup 9 = {
		1
	} elif dup 32 = {
		1
	} else {
		0
	}
	swap drop
}

; (str len)
fn scan_file 2 0 {
	auto file_path 2
	pop file_path

	auto fp_string_view 1
	file_path new_string_view pop fp_string_view

	auto data     1
	auto data.len 1

	-> 0 {
		file_path open_and_mmap_fp
		pop data.len pop data
	}
	
	auto pos 1 0 pop pos
	auto row 1 0 pop row
	auto col 1 0 pop col

	while 1 {
		reserve is_number 1
		is_number 1 w8

		pos data.len >= if {
			break
		}
		while data pos u8[] dup is_whitespace {
			LF_CH = if {
				row ++ pop row
				0      pop col
			} else {
				col ++ pop col
			}
			pos ++ pop pos
			pos data.len >= if {
				break
			}	
		}
		pos data.len >= if {
			break
		}

		auto start     1 pos pop start
		auto start_col 1 col pop start_col

		while data pos u8[] is_whitespace true != {
			is_number r8 if {
				data pos u8[] dup 0_CH >= swap 9_CH <= & true != if {
					is_number 0 w8
				}
			}

			; handle special tokens
			; '', "", ;, {, }, ->

			col ++ pop col
			pos ++ pop pos
			pos data.len >= if {
				break
			}
		}

		is_number r8 if {
			row col fp_string_view Tok.number_lit
			999 ; implement string view to number
			token_stream<<
		} else {
			; (row col file)
			row col fp_string_view

			auto lit 2
				data start + 
				pos start -
			pop lit

			; (row col file tok)
			lit Tok.from_str

			; (row col file tok data)
			dup Tok.name = if {
				lit new_string_view
			} else {
				0
			}

			token_stream<<
		}
	}

	; TODO: complex for break and continue
}