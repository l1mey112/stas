; (bool -- str len)
fn bool_to_str 1 2 {
	if {
		"true"
	} else {
		"false"
	}
}

; (ptr -- str len)
fn cstr_to_stastr 1 2 {
	dup strlen     ; (str len)
}

; (idx -- str len)
fn args[] 1 2 {
	dup argc >= if {
		drop NULL 0 ret
	}

	8 * argv + r64 ; (cstr)
	cstr_to_stastr ; (str len)
}

; (*argv)
fn argp_print 1 0 {
	while true {
		dup r64 cstr_to_stastr eputs
		sizeof(u64) +
		
		dup r64 NULL = if {
			break
		} else {
			32 eputc
		}
	}
	drop
}

; (u8 -- bool)
fn is_dec 1 1 {
	dup `0` >= swap `9` <= &
}

; (idx ptr -- u8)
fn u8[] 2 1 {
	+ r8
}

; (idx ptr -- u64)
fn u64[] 2 1 {
	swap sizeof(u64) * + r64
}

; (str len -- number bool)
fn str_to_num? 2 2 {
	auto str.len 1 pop str.len
	auto str     1 pop str

	0 0 ; (num idx)
	while dup str.len < {
		swap 10 *
		over str u8[]
			dup is_dec ! if {
				drop drop drop 0 false ret
			}
		48 - ; `0`
		+ swap
		++
	}
	drop
	true
}

; (str len -- number)
fn str_to_num 2 1 {
	str_to_num? assert
}

; (u64)
fn negate 1 1 {
	~ ++
}

; (lo hi str len *Array64)
fn get_lines_into_array 5 0 {
	auto arr 1        pop arr
	auto len 1 over + pop len
	auto st  1
	
	auto offset 1
	auto count  1

	dup pop st

	rot swap
	; (str hi lo)
	pop offset
	; (str hi)
	swap
	while dup len < {
		; (hi str)
		dup r8 `\n` = if {
			offset 0 > if {
				offset -- pop offset
			} else {
				over 0 > if {
					dup st - ++ st arr Array64<< ; str
					               arr Array64<< ; len
					swap -- swap
				} else {
					break
				}
			}
			dup ++ pop st
		}
		++
	}
	offset 0 = if {
		over 0 > if {
			dup st - ++ st arr Array64<< ; str
			               arr Array64<< ; len
		}
	}
	drop drop
}

; ( str len -- str? len )
fn getenv 2 2 {
	auto str 2 pop str

	envp
	while dup r64 NULL != {
		dup
		
		r64 cstr_to_stastr
		over over str string.starts_with if {
			`=` string.after_delim_u8
			; (envp 'str 'len)
			rot rot drop ret
		} else {
			drop drop
		}
		
		sizeof(u64) +
	}
	drop

	NULL 0
}