; (ptr ptr len -- bool)
fn memeq 3 1 {
	auto len 1

	pop len ; (ptr ptr)

	0                 
	while dup len < {       ; (ptr_1 ptr_2 idx)
		rot dup r8          ; (idx ptr_1 ptr_2 u8_2)
		rot swap dup r8     ; (idx u8_2 ptr_2 ptr_1 u8_1)
		rot                 ; (idx u8_2 u8_1 ptr_2 ptr_1)
		++ rot4 ++ rot4     ; (idx ptr_2 ptr_1 u8_2 u8_1)

		!= if {             ; (idx ptr_2 ptr_1 bool)
			drop drop drop 0 ret
		}

		rot swap            ; (ptr_1 ptr_2 idx)
		++
	}
	drop drop drop
	1
}

; (str len str len -- bool)
fn streq 4 1 {
	over2 over ; (len len)
	!= if {
		drop drop drop drop 0 ret
	}
	
	; (str len str len)
	
	drop swap ; (str str len)
	memeq
}

; (dest src len)
fn memcpy 3 0 {
	swap rot
	; (src dest len)
	; legacy memcpy impl, rewrite it later

	while dup 0 > {   ; (ptr1 ptr2 len)
		rot           ; (len ptr1 ptr2)
		swap dup r8   ; (len ptr2 ptr1 u8-1)
		over2 swap w8 ; (len ptr2 ptr1)
		++ swap ++    ; (len ptr1 ptr2)
		rot rot --    ; (ptr1 ptr2 len)
	}
	drop drop drop
}

; (ptr int len)
fn memset 3 0 {
	while dup 0 > {  ; (ptr int len)
		rot          ; (len ptr int)
		over over    ; (len ptr int ptr int)
		w8           ; (len ptr int)
		swap ++ swap ; (len ptr int)
		rot rot --   ; (ptr int len)     
	}
	drop drop drop
}

; (str -- len)
fn strlen 1 1 {
	dup
	while dup r8 0 != {
		++
	}
	swap -
}

; ( str len u8 -- str len )
fn string.after_delim_u8 3 2 {
	over 0 = if { ; len == 0
		drop ret
	}

	; (str len u8)
	
	auto ch    1 pop ch
	auto t_len 1 
	
	; (str len)
	over over +
	; (str len str+len)
	pop t_len

	swap

	; (len str)
	while dup t_len < {
		; (len str)
		dup r8 ch = if {
			++ swap -- ret
		}
			++
		swap
			--
		swap
	}
	drop
	drop

	NULL 0
}

; ( str len u8 -- 'str 'len str len )
fn string.after_delim_u8.ret_both 3 4 {
	auto a     1
	auto a.len 1

	over2 over2 pop a.len pop a

	; (str len u8)
	string.after_delim_u8 over NULL = if {
		drop drop a a.len NULL 0 ret
	}
	
	; (str len)

	a over2 swap - ; new len
	-- ; do not include delim
	rot a rot4
}

; ( str len d_str d_len -- bool )
fn string.starts_with 4 1 {
	; (str len d_str d_len)
	over2 over < if { ; str.len < delim.len
		drop drop drop drop false ret
	}

	auto dl 1
	dup pop dl

	; (str d_str d_len len)
	rot rot drop dl rot
	; (str d_len d_str d_len)
	streq
}

fn string.assert 2 2 {
	over over assert assert
}

; ( str len u8 -- str len )
fn string.trim_len_delim_u8 3 2 {
	auto ch 1 pop ch

	; (str len)
	while dup 0 > {
		dup -- over2 + r8 ch = if {
			--
		} else {
			break
		}
	}
}