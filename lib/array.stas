fn Array64.data      1 1 {      }
fn Array64.len       1 1 { 8  + }
fn Array64.cap       1 1 { 16 + }
const sizeof(Array64)    { 24   }
; (ptr -- data)
fn rArray64.data     1 1 { Array64.data     r64 }
fn rArray64.len      1 1 { Array64.len      r64 }
fn rArray64.cap      1 1 { Array64.cap      r64 }
; (ptr data)
fn wArray64.data     2 0 { swap Array64.data swap w64 }
fn wArray64.len      2 0 { swap Array64.len  swap w64 }
fn wArray64.cap      2 0 { swap Array64.cap  swap w64 }

; (data *Array64 -- bool)
fn Array64<<? 2 1 {
	auto array 1 pop array
	
	array
	 dup rArray64.len
	swap rArray64.cap >= if {
		drop false ret
	}

	array
	 dup rArray64.len sizeof(u64) *
	swap rArray64.data +

	swap w64

	array Array64.len p64++

	true
}
; (*Array64 -- data bool)
fn Array64.top? 1 2 {
	auto array 1 pop array
	array rArray64.len 0 = if {
		0 false ret
	}

	array
	 dup rArray64.len -- sizeof(u64) *
	swap rArray64.data + r64

	true
}
; (*Array64 -- data bool)
fn Array64.pop? 1 2 {
	dup Array64.top? ! if {
		drop drop 0 false ret
	}

	swap Array64.len p64--

	true
}
; (data *Array64)
fn Array64<< 2 0 {
	Array64<<? assert -> 'Array64<<: append exceeded bounds in Array64'
}
; (*Array64 -- u64)
fn Array64.top 1 1 {
	Array64.top? assert -> 'Array64.top: array is empty'
}
; (*Array64 -- u64)
fn Array64.pop 1 1 {
	Array64.pop? assert -> 'Array64.pop: array is empty'
}
; (size *Array64)
fn Array64.init_alloc_size 2 0 {
	auto sz 1 swap pop sz

	; (*Array64)
	dup sz sizeof(u64) * memory.mmap_anon wArray64.data
	; (*Array64)
	dup sz wArray64.cap
	    0  wArray64.len
}
; (*Array64)
fn Array64.print 1 0 {
	auto arr 1 pop arr

	"Array64 {\n" puts
	"	data: " puts arr rArray64.data putuln
	"	len:  " puts arr rArray64.len  putuln
	"	cap:  " puts arr rArray64.cap  putuln
	"}\n" puts
}

;fn Array.data     1 1 {      }
;fn Array.len      1 1 { 8  + }
;fn Array.cap      1 1 { 16 + }
;fn Array.elm_size 1 1 { 24 + }
;const sizeof(Array)   { 32   }
;; (ptr -- data)
;fn rArray.data     1 1 { Array.data     r64 }
;fn rArray.len      1 1 { Array.len      r64 }
;fn rArray.cap      1 1 { Array.cap      r64 }
;fn rArray.elm_size 1 1 { Array.elm_size r64 }
;; (ptr data)
;fn wArray.data     2 1 { swap Array.data     swap w64 }
;fn wArray.len      2 1 { swap Array.len      swap w64 }
;fn wArray.cap      2 1 { swap Array.cap      swap w64 }
;fn wArray.elm_size 2 1 { swap Array.elm_size swap w64 }
;
;; (*data *Array -- bool)
;fn Array<<*? 2 1 {
;	auto array 1 pop array
;	
;	array
;	 dup rArray.len
;	swap rArray.cap >= if {
;		drop false ret
;	}
;
;	array
;	 dup rArray.len over rArray.elm_size *
;	swap rArray.data +
;	
;	swap
;	array rArray.elm_size
;	memcpy
;	
;	array Array64.len p64++
;
;	true
;}
;
;; (data *Array64)
;fn Array<<* 2 1 {
;	Array<<*? assert -> 'append exceeded bounds in Array'
;}