fn Array64.data      1 1 {      }
fn Array64.len       1 1 { 8  + }
fn Array64.cap       1 1 { 16 + }
const sizeof(Array64)    { 24   }
; (ptr -- data)
fn rArray64.data     1 1 { Array64.data     r64 }
fn rArray64.len      1 1 { Array64.len      r64 }
fn rArray64.cap      1 1 { Array64.cap      r64 }
; (ptr data)
fn wArray64.data     2 0 { swap Array64.data swap w64 }
fn wArray64.len      2 0 { swap Array64.len  swap w64 }
fn wArray64.cap      2 0 { swap Array64.cap  swap w64 }

; (data *Array64 -- bool)
fn Array64<<? 2 1 {
	auto array 1 pop array
	
	array
	 dup rArray64.len
	swap rArray64.cap >= if {
		drop false ret
	}

	array
	 dup rArray64.len sizeof(u64) *
	swap rArray64.data +

	swap w64

	array Array64.len p64++

	true
}
; (*Array64 -- data bool)
fn Array64.top? 1 2 {
	auto array 1 pop array
	array rArray64.len 0 = if {
		0 false ret
	}

	array
	 dup rArray64.len -- sizeof(u64) *
	swap rArray64.data + r64

	true
}
; (*Array64 -- data bool)
fn Array64.pop? 1 2 {
	dup Array64.top? ! if {
		drop drop 0 false ret
	}

	swap Array64.len p64--

	true
}
; (idx *Array64 -- data bool)
fn Array64[]? 2 2 {
	auto arr 1 pop arr

	dup arr rArray64.len >= if {
		drop 0 false ret
	}

	sizeof(u64) *
	arr rArray64.data + r64

	true
}
; (idx *Array64 -- data)
fn Array64[] 2 1 {
	Array64[]? assert -> 'Array64[]: index out of bounds'
}
; (data *Array64)
fn Array64<< 2 0 {
	Array64<<? assert -> 'Array64<<: append exceeded bounds in Array64'
}
; (*Array64 -- u64)
fn Array64.top 1 1 {
	Array64.top? assert -> 'Array64.top: array is empty'
}
; (*Array64 -- u64)
fn Array64.pop 1 1 {
	Array64.pop? assert -> 'Array64.pop: array is empty'
}
; (size *Array64)
fn Array64.init_alloc_size 2 0 {
	auto sz 1 swap pop sz

	; (*Array64)
	dup sz sizeof(u64) * memory.mmap_anon wArray64.data
	; (*Array64)
	dup sz wArray64.cap
	    0  wArray64.len
}
; (buffer size *Array64)
fn Array64.init_with_buffer_sz_bytes 3 0 {
	auto arr 1 pop arr

	sizeof(u64) / arr swap wArray64.cap
	arr 0    wArray64.len
	arr swap wArray64.data
}
; (buffer size *Array64)
fn Array64.init_with_buffer_sz_elm 3 0 {
	auto arr 1 pop arr

	arr swap wArray64.cap
	arr 0    wArray64.len
	arr swap wArray64.data
}
; (*Array64)
fn Array64.print 1 0 {
	auto arr 1 pop arr

	"Array64 {\n" puts
	"	data: " puts arr rArray64.data putuln
	"	len:  " puts arr rArray64.len  putuln
	"	cap:  " puts arr rArray64.cap  putuln
	"}\n" puts
}
; (*Array64)
fn Array64.dump 1 0 {
	auto arr.len 1

	dup
	rArray64.len pop arr.len
	
	91 putc ; `[`

	rArray64.data 0
	while dup arr.len < {
		swap
			dup r64
			putu
			sizeof(u64) +
		swap
		dup arr.len -- < if {
			", " puts
		}
		++
	}
	drop drop

	93 putc ; `]`
	endl
}