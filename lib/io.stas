const stdin  { 0 }
const stdout { 1 }
const stderr { 2 }
const EOF    { UINT64_MAX }

fn endl 0 0 {
	stdout "\n" write drop
}

; (buf num -- str len)
fn itoa 2 2 {
	auto buf 1
	swap pop buf

	auto pos 1
	auto len 1

	dup 0 = if {
		drop

		buf 48    w8
		buf 1 + 0 w8
		buf 1
		
		ret
	}
	
	0 pop len
	buf 21 + pop pos

	while dup 0 > {
		pos -- pop pos

		10 %%
		48 +

		pos swap w8

		len ++ pop len
	}
	drop

	;buf len + 0 w8

	pos len
}

; (stream num)
fn fputu 2 0 {
	auto stream 1
	swap pop stream

	reserve buf 20
	auto pos 1
	auto len 1

	dup 0 = if {
		drop

		buf 48 w8
		stream buf 1 write drop
		
		ret
	}
	
	0 pop len
	buf 20 + pop pos

	while dup 0 > {
		pos -- pop pos

		10 %%
		48 +

		pos swap w8

		len ++ pop len
	}
	drop

	stream pos len write drop
}

; (stream num padding)
fn fputpu_space 3 0 {
	auto padding 1 pop padding
	auto stream  1
	swap pop stream

	reserve buf 20
	auto pos 1
	auto len 1

	dup 0 = if {
		drop

		buf 48 w8
		stream buf 1 write drop
		
		ret
	}
	
	0 pop len
	buf 20 + pop pos

	while dup 0 > {
		pos -- pop pos

		10 %%
		48 +

		pos swap w8

		len ++ pop len
	}
	drop

	len padding < if {
		padding len - while dup 0 > {
			pos -- pop pos
			pos ` ` w8
			len ++ pop len
			--
		}
		drop
	}

	stream pos len write drop
}

; (stream num padding)
fn fputpu 3 0 {
	auto padding 1 pop padding
	auto stream  1
	swap pop stream

	reserve buf 20
	auto pos 1
	auto len 1

	dup 0 = if {
		drop

		buf 48 w8
		stream buf 1 write drop
		
		ret
	}
	
	0 pop len
	buf 20 + pop pos

	while dup 0 > {
		pos -- pop pos

		10 %%
		48 +

		pos swap w8

		len ++ pop len
	}
	drop

	len padding < if {
		padding len - while dup 0 > {
			pos -- pop pos
			pos 48 w8
			len ++ pop len
			--
		}
		drop
	}

	stream pos len write drop
}

; (stream ch)
fn fgetc 1 1 {
	reserve ch 1
	ch 1 read
	0 = if {
		EOF
	} else {
		ch r8
	}
}

; (buf size stream -- str len)
fn fgets 3 2 {
	auto stream 1      pop stream
	auto buf    1 swap pop buf
	auto bufp   1 buf  pop bufp
	auto c      1
	auto count  1 0    pop count
	
	--
	while dup 0 > {
		stream fgetc pop c
		c EOF = if {
			drop NULL 0 ret
		}
		bufp c w8
		count ++ pop count
		c 10 = if {
			break
		}
		bufp  ++ pop bufp
		--
	}
	drop

	bufp 0 w8
	
	c EOF = buf bufp = & if {
		NULL 0
	} else {
		buf count
	}
}

; (num)
fn putu 1 0 {
	stdout swap fputu
}

; (num)
fn eputu 1 0 {
	stderr swap fputu
}

; (num)
fn putuln 1 0 {
	stdout swap fputu
	endl
}

; (num)
fn eputuln 1 0 {
	stderr swap fputu
	endl
}

; (num padding)
fn putpu 2 0 {
	stdout rot fputpu
}

; (num padding)
fn eputpu 2 0 {
	stderr rot fputpu
}

; (str len)
fn puts 2 0 {
	stdout rot write drop
}

; (str len)
fn eputs 2 0 {
	stderr rot write drop
}

; (ch)
fn putc 1 0 {
	reserve ch 1
	ch swap w8
	stdout ch 1 write drop
}

; (ch)
fn eputc 1 0 {
	reserve ch 1
	ch swap w8
	stderr ch 1 write drop
}

fn getc 0 1 {
	stdin fgetc
}


; (fd -- size)
fn fd_stat_size 1 1 {
	reserve struct_stat sizeof(stat)

	; (fd)
	struct_stat fstat 0 <s if {
		"FATAL: Failed to stat the file descriptor\n" eputs
		1 exit
	}

	struct_stat stat.st_size r64
}

; (str len -- fd)
fn fd_open_fp_readonly 2 1 {
	auto path 2
	pop path

	path drop

	O_RDONLY 0 open

	dup 0 <s if {
		"FATAL: Failed to open file '" eputs path eputs "'\n" eputs
		1 exit
	}
}

; (str len -- fd)
fn fd_new_file_for_writing 2 1 {
	auto path 2
	pop path

	path drop

	O_WRONLY O_CREAT | O_TRUNC | S_RWE_OWNER open

	dup 0 <s if {
		"FATAL: Failed to open file '" eputs path eputs "'\n" eputs
		1 exit
	}
}

; (str len -- ptr len)
fn open_and_mmap_fp 2 2 {
	auto path 2
	pop path

	auto fd 1
	path fd_open_fp_readonly pop fd

	auto len 1
	fd fd_stat_size pop len

	len 0 > if {
		0
		len
		PROT_READ
		MAP_PRIVATE
		fd
		NULL
		mmap

		dup 0 <s if {
			"FATAL: Could not mmap file '" eputs path eputs "'\n" eputs
			1 exit
		}

		len
	} else {
		NULL 0
	}

	fd close 0 <s if {
		"FATAL: Failed to close file descriptor\n" eputs
		1 exit
	}
}

; (execute.str execute.len argv[] is_blocking)
fn child_execve_and_shut_up 4 0 {
	auto is_blocking 1 pop is_blocking
	swap drop
	
	auto args 2
	pop args
	
	fork

	dup 0 = if {
		reserve null_p sizeof(u64)
		null_p NULL w64

			AT_FDCWD
			"/dev/null" drop
			O_RDONLY
			0
		openat

		dup 0 <s if {
			"FATAL: Could not open /dev/null\n" eputs
			1 exit
		}

		stdout

		dup2 0 <s if {
			"FATAL: Could not open /dev/null as stdout\n" eputs
			1 exit
		}

		args null_p execve 0 <s if {
			"FATAL: Could not execve child" eputs
			1 exit
		}

		0 exit
	} elif dup 0 >s {
		is_blocking if {
			auto loop 1
			true pop loop
			
			reserve proc_status sizeof(u64)

			while loop {
				UINT64_MAX
				proc_status
				0
				NULL
				
				wait4 0 <s if {
					"FATAL: Could not wait for process" eputs
					1 exit
				}

				proc_status r64
				dup WIFEXITED if {
					dup WEXITSTATUS 
					dup 0 >s if {
						dup exit	
					}
					drop
					false pop loop
				} elif dup WIFSIGNALED {
					"FATAL: Child process was terminated by signal " eputs dup WTERMSIG eputuln
					255 exit
					false pop loop
				} elif dup WIFSTOPPED {
					
				} elif dup WIFCONTINUED {
					
				} else {
					0 assert -> 'unreachable'
				}
				drop
			}
		}
	} else {
		"FATAL: Could not fork child" eputs
		1 exit
	}
	drop
}