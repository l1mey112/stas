; main: (argc u64, argv *) do
;     argc
;     while @ 0 > do
;         @ argc ~ -=
;         argv [] puts
;         --
;     end
; end

; you cannot do something like argc-- because it
; will be interpreted as Tok.name Tok.dec with 0
; context

my_func in a_in do
    stack var 0

    if a_in 0 > do
        a_in pop var
    else
        stack var_a 0
        stack var_b 255

        a_in _
    end

    var
end

; count 3 variables?
; at the start of the function, do `sub rsp, 24`
; then push the inputs, `push rdi`
; when the var is initialised, 

; push rbp
; mov rbp, rsp
; sub rsp, 24
; 
; do stuff
; mov qword [rbp - 8 ], 0   ; var
; mov qword [rbp - 16], 0   ; var_a
; mov qword [rbp - 24], 255 ; var_b
; 
; leave
; ret


my_func in input_a do
    ; start
    local var_a 255
    ; end
end
; my_func:
;   push rbp
;   mov rbp, rsp
;   mov qword [rbp - 8], rdi ; input_a
;   ; sub rsp, 16 - ommitted if it does not create a stack frame (ie call other functions)
;   ; start
;   mov qword [rbp - 16], 255 ; var_a
;   ; end
;   ; leave - no stack frame! leave this out
;   ret

main in do
    argc
    while @ 0 > do
        @ argc ~ -=
        argv [] puts
        --
    end
end

; if i can get below working
; ive done it!

recurse_fibonacci in count do
    if count 0 = do
        0 return
    else if count 1 = do
        1 return
    else
        count 1 -= recurse_fibonacci
        count 2 -= recurse_fibonacci
        += return
    end end
end

main in do
    0  recurse_fibonacci uputln ; 0
    1  recurse_fibonacci uputln ; 1
    10 recurse_fibonacci uputln ; 55
    22 recurse_fibonacci uputln ; 17711
end

; ehh????
; figure this out maybe?

printf in ! do
    ; variadic???
end

main in do
    "%d\n"
    @ 0  recurse_fibonacci printf ; 0
    @ 1  recurse_fibonacci printf ; 1
    @ 10 recurse_fibonacci printf ; 55
    @ 22 recurse_fibonacci printf ; 17711
end

; -- test


;main in do
;	local a_in 22
;
;	if a_in 10 > do
;		"Greater than 10" println	
;	else if a_in 5 < do
;		"Less than 5" println
;	else
;		"In between 5 and 10" println
;	end
;end

;recurse_fibonacci in count do
;    if count 0 = do
;        0 return
;    else if count 1 = do
;        1 return
;    else
;        count 1 -= recurse_fibonacci
;        count 2 -= recurse_fibonacci
;        += return
;    end end
;end
;
;main in do
;    0  recurse_fibonacci uputln ; 0
;    1  recurse_fibonacci uputln ; 1
;    10 recurse_fibonacci uputln ; 55
;    22 recurse_fibonacci uputln ; 17711
;end