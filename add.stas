include 'std.stas'

const HEIGHT  { 20 }
const WIDTH   { 40 }
const BUFSIZE { WIDTH HEIGHT * } 

; ( x y buffer -- u8 bool )
fn r_cell? 3 2 {
	rot
	; (buffer x y)
	dup putu " " puts over putuln
	over WIDTH >= if {
		drop drop drop 0 false ret
	}
	dup HEIGHT >= if {
		drop drop drop 0 false ret
	}
	WIDTH * + + r8 true
}

; ( x y buffer -- u8 )
fn r_cell 3 1 {
	r_cell? assert -> 'r_cell: coord out of bounds'
}

; ( x y buffer u8 )
fn w_cell 4 0 {
	rot4 rot
	; (u8 buffer x y)
	over WIDTH  < assert
	dup  HEIGHT < assert
	WIDTH * + + swap w8
}

; ( x y buffer -- u8 )
fn probe_cell 3 1 {
	r_cell? drop ; if out of bounds, return zero neighbours
}

; ( x y buffer -- count )
fn neighbors_cell 3 1 {
	auto b 1   pop b
	auto y 1   pop y
	auto x 1   pop x
	auto c 1 0 pop c 

	y -- while dup y ++ <= {
		dup 0 >=s if {
			x -- while dup x ++ <= {
				; (y x)
				dup
				; (y x x)
				0 >=s if {
					'inside ' puts
					dup over2
					; (y x x y)
					b probe_cell c + pop c
				}
				++
			}
			drop
		}
		++
	}
	drop

	c ; exclude self
}

; (buffer)
fn iterate_gol 1 0 {
	reserve buffer_old BUFSIZE
	buffer_old swap BUFSIZE memcpy

	0 while dup HEIGHT < {
		0 while dup WIDTH < {
			; (y x)
			; over pop y
			; dup  pop x
			
			; buffer_old r_cell

			0 assert -> 'unimplemented'
			
			++
		}
		drop
		++
		endl
	}
	drop
}

fn main 0 0 {
	reserve buffer BUFSIZE

	buffer 1 BUFSIZE memset

	0 0 buffer neighbors_cell putuln

	while true {
		buffer
		0 while dup HEIGHT < {
			0 while dup WIDTH < {
				; (buffer h w)
				rot rot
					dup r8 if {
						`#` putc
					} else {
						` ` putc
					}
					++
				rot
				++
			}
			drop
			++
			endl
		}
		drop
		drop ; buffer idx
		
		getc drop
		21 term.cursor_up
	}
}