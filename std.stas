define StackSize 8 enddef

fn double 1 2 do
	asm 1 2
"	mov rdi, [rsp]
	push rdi"
endfn

define drop
	asm 1 0
"	add rsp, 8"
enddef

define ptrinc
	double deref64 ++ write64
enddef

define ptrdec
	double deref64 -- write64
enddef

; keep in mind that macros are not recursive, yet.
; you cannot call macros inside macros.

; i want double to be a macro, but it cannot

fn deref8 1 1 do
	asm 1 1
"	pop rdi
	movsx rdi, byte [rdi]
	push qword rdi"
endfn

fn swap 2 2 do
	asm 2 2
"	pop rdi
	pop rsi
	push rdi
	push rsi"
endfn

fn rot 3 3 do
	reserve StackSize rot1
	reserve StackSize rot2
	reserve StackSize rot3

	rot1 swap write64
	rot2 swap write64
	rot3 swap write64

	rot1 deref64
	rot3 deref64
	rot2 deref64
endfn

fn write 2 0 do
	1 rot 1 rot syscall3
	drop
endfn

fn strlen 1 1 do
	double
	while double deref8 0 != do
		++
	endwhile
	swap -
endfn

fn endl 0 0 do
	reserve 1 newline
	newline 10 write8
	newline 1 write
endfn

fn println 1 0 do
	double strlen write
	endl
endfn

fn deref64 1 1 do
	asm 1 1
"	pop rdi
	push qword [rdi]"
endfn

fn write64 2 0 do
	asm 2 0
"	pop rax
	pop rdi
	mov qword [rdi], rax"
endfn

fn write8 2 0 do
	asm 2 0
"	pop rax
	pop rdi
	mov byte [rdi], al"
endfn

fn syscall3 4 1 do
	asm 4 1
"	pop rdx
	pop rsi
	pop rdi
	pop rax
	syscall
	push rax"
endfn

fn getch 0 1 do
	reserve 1 ch
	
	0 0 ch 1 syscall3
	drop

	ch deref8 
endfn

fn uput 1 0 do
	reserve 20 buf
	reserve StackSize pos
	reserve StackSize len

	double

	0 = if
		buf 48 write8
		buf 1 write
		ret           ; ret doesn't worry about unhandled
	endif             ; values on the stack

	len 0 write64
	pos buf 20 + write64

	while double 0 > do
		pos ptrdec

		10 %%
		48 +

		pos deref64 swap write8

		len ptrinc
	endwhile
	drop

	pos deref64 len deref64 write
endfn

fn uputln 1 0 do
	uput
	endl
endfn